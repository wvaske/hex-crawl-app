---
phase: 06-map-image-upload
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/client/src/stores/useImageLayerStore.ts
  - packages/client/src/canvas/layers/ImageLayer.tsx
  - packages/client/src/components/MapView.tsx
  - packages/client/vite.config.ts
autonomous: true

must_haves:
  truths:
    - "Uploaded map images render as background sprites beneath the hex grid"
    - "Multiple image layers render in sortOrder with independent offset/scale"
    - "Hiding a layer removes its sprite from the viewport"
  artifacts:
    - path: "packages/client/src/stores/useImageLayerStore.ts"
      provides: "Zustand store for image layer state"
      exports: ["useImageLayerStore"]
    - path: "packages/client/src/canvas/layers/ImageLayer.tsx"
      provides: "PixiJS container rendering image sprites"
  key_links:
    - from: "packages/client/src/canvas/layers/ImageLayer.tsx"
      to: "packages/client/src/stores/useImageLayerStore.ts"
      via: "useImageLayerStore subscription for layers array"
    - from: "packages/client/src/components/MapView.tsx"
      to: "packages/client/src/canvas/layers/ImageLayer.tsx"
      via: "ImageLayer as first child of viewport (before TerrainLayer)"
---

<objective>
Create the client-side image rendering: Zustand store for image layer state, PixiJS ImageLayer component that renders background image sprites, and wire into MapView as the bottom-most viewport layer.

Purpose: Makes uploaded map images visible beneath the hex grid in the canvas.
Output: ImageLayer component rendering in viewport, Zustand store managing layer data.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-map-image-upload/06-RESEARCH.md
@.planning/phases/06-map-image-upload/06-CONTEXT.md
@packages/client/src/canvas/layers/TerrainLayer.tsx
@packages/client/src/canvas/layers/TokenLayer.tsx
@packages/client/src/components/MapView.tsx
@packages/client/src/stores/useMapStore.ts
@packages/client/src/stores/useTokenStore.ts
@packages/client/vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Image layer Zustand store</name>
  <files>
    packages/client/src/stores/useImageLayerStore.ts
  </files>
  <action>
    Create `useImageLayerStore` following the same pattern as useTokenStore/useMapStore:

    State:
    - layers: ImageLayer[] (sorted by sortOrder)
    - alignmentMode: boolean (false initially)
    - aligningLayerId: string | null

    ImageLayer type:
    - id, mapId, fileName, storageKey, contentType, fileSize
    - offsetX, offsetY, scaleX, scaleY
    - sortOrder, visible, playerVisible
    - url (computed from storageKey or returned by server)

    Actions:
    - setLayers(layers) — replace all layers (from REST fetch)
    - addLayer(layer) — add a layer (from WS layer:added)
    - updateLayer(id, updates) — partial update (from WS layer:updated or local alignment)
    - removeLayer(id) — remove (from WS layer:removed)
    - enterAlignmentMode(layerId) — set alignmentMode true, aligningLayerId
    - exitAlignmentMode() — reset alignment state
    - reorderLayers(orderedIds) — update sortOrder based on new ID ordering

    Use `new Map()` or spread patterns for reactivity as established in existing stores.
  </action>
  <verify>Run `pnpm --filter @hex-crawl/client tsc --noEmit` passes.</verify>
  <done>useImageLayerStore exports with all state and actions, compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: ImageLayer PixiJS component + MapView wiring + Vite proxy</name>
  <files>
    packages/client/src/canvas/layers/ImageLayer.tsx
    packages/client/src/components/MapView.tsx
    packages/client/vite.config.ts
  </files>
  <action>
    1. Create `packages/client/src/canvas/layers/ImageLayer.tsx`:
       - Subscribe to useImageLayerStore for layers array
       - Use a ref to a PixiJS Container
       - On layers change: destroy old sprites, create new Sprite for each visible layer (sorted by sortOrder)
       - For each layer: `await Assets.load(layer.url)` to get texture, create Sprite, set position (offsetX, offsetY), set scale (scaleX, scaleY), addChild to container
       - Track sprites in a Map<string, Sprite> ref for efficient updates
       - Cleanup: destroy sprites on unmount
       - Return `<pixiContainer ref={...} />` (or `<container>` depending on @pixi/react API — match existing layer components)

    2. Edit `packages/client/src/components/MapView.tsx`:
       - Import ImageLayer
       - Add `<ImageLayer />` as the FIRST child inside the viewport, BEFORE TerrainLayer
       - This ensures images render behind everything else (PixiJS child order = z-order)

    3. Add Vite proxy for `/uploads` in `packages/client/vite.config.ts`:
       ```typescript
       '/uploads': {
         target: 'http://localhost:3000',
         changeOrigin: true,
       }
       ```
       Add alongside existing proxy entries.

    Follow the exact @pixi/react patterns used in TerrainLayer.tsx and TokenLayer.tsx for container refs and sprite management.
  </action>
  <verify>Run `pnpm --filter @hex-crawl/client tsc --noEmit` passes. Start dev server, verify no render errors in console. ImageLayer component mounts without errors (even with no layers loaded yet).</verify>
  <done>ImageLayer renders as first viewport child. Vite proxies /uploads to server. Empty layer list causes no errors.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @hex-crawl/client tsc --noEmit` passes
2. ImageLayer is first child in viewport (before TerrainLayer)
3. Vite proxy for /uploads configured
4. Store has all required state and actions
</verification>

<success_criteria>
Client can render uploaded map images as background sprites beneath the hex grid, with a Zustand store managing layer state and proper z-ordering in the viewport.
</success_criteria>

<output>
After completion, create `.planning/phases/06-map-image-upload/06-02-SUMMARY.md`
</output>
