---
phase: 04-fog-of-war
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/server/src/ws/fog-utils.ts
  - packages/server/src/ws/message-handlers.ts
  - packages/server/src/ws/handler.ts
  - packages/server/src/ws/session-manager.ts
autonomous: true

must_haves:
  truths:
    - "When DM reveals hexes, they are persisted to hex_visibility and broadcast to target players"
    - "When DM hides hexes, they are deleted from hex_visibility and hex:hidden is broadcast"
    - "On WS connect, players receive ONLY revealed + adjacent hex terrain (FOG-05 enforced)"
    - "DM receives full map data on connect; players receive filtered data"
    - "Fog state persists across server restarts (loaded from DB on room creation)"
  artifacts:
    - path: "packages/server/src/ws/fog-utils.ts"
      provides: "getNeighborKeys, computeAdjacentHexes, buildPlayerFogPayload, loadFogState, loadMapData"
    - path: "packages/server/src/ws/message-handlers.ts"
      provides: "handleHexHide handler, updated handleHexReveal with DB persistence"
      contains: "handleHexHide"
    - path: "packages/server/src/ws/handler.ts"
      provides: "Filtered session:state with adjacentHexes and terrain-only data for players"
      contains: "adjacentHexes"
  key_links:
    - from: "packages/server/src/ws/fog-utils.ts"
      to: "packages/server/src/ws/message-handlers.ts"
      via: "import computeAdjacentHexes, buildPlayerFogPayload"
      pattern: "import.*fog-utils"
    - from: "packages/server/src/ws/fog-utils.ts"
      to: "packages/server/src/ws/handler.ts"
      via: "import loadFogState, loadMapData, buildPlayerFogPayload"
      pattern: "import.*fog-utils"
    - from: "packages/server/src/ws/handler.ts"
      to: "hex_visibility DB table"
      via: "loadFogState query on connect"
      pattern: "hexVisibility"
---

<objective>
Implement server-side fog logic: adjacency computation, persistent reveal/hide with DB writes, filtered session:state payloads that enforce FOG-05 (players never receive unrevealed terrain data), and fog state loading from DB on connection.

Purpose: This is the security-critical plan. Without server-side enforcement, players could inspect network traffic and see unrevealed terrain. Every hex data transmission to players must be filtered through fog state.

Output: fog-utils.ts with adjacency computation, updated message handlers with persistence, filtered connect payloads.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-fog-of-war/04-01-SUMMARY.md
@packages/server/src/ws/session-manager.ts
@packages/server/src/ws/message-handlers.ts
@packages/server/src/ws/handler.ts
@packages/shared/src/ws-messages.ts
@packages/shared/src/hex-types.ts
@packages/client/src/hex/neighbors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fog-utils and update session manager</name>
  <files>
    packages/server/src/ws/fog-utils.ts
    packages/server/src/ws/session-manager.ts
  </files>
  <action>
    1. Create `packages/server/src/ws/fog-utils.ts` with:
       - `FLAT_TOP_DIRECTIONS` array (same as client's neighbors.ts): [{q:1,r:0},{q:1,r:-1},{q:0,r:-1},{q:-1,r:0},{q:-1,r:1},{q:0,r:1}]
       - `getNeighborKeys(key: string): string[]` — parse "q,r" key, compute 6 neighbors, return as "q,r" strings. Use simple split/join, not importing from shared (server doesn't have parseHexKey — OR import it if shared exports it. Check: shared exports `parseHexKey` and `hexKey` — USE THOSE).
       - `computeAdjacentHexes(revealedKeys: Set<string>, allHexKeys: Set<string>): Set<string>` — for each revealed key, get neighbors; add to result if not in revealedKeys but in allHexKeys.
       - `buildPlayerFogPayload(playerRevealedKeys: Set<string>, allHexData: Map<string, { terrain: string }>): { revealedHexes: string[], adjacentHexes: Array<{ key: string, terrain: string }> }` — compute adjacent, return revealed keys + adjacent with terrain-only data.
       - `loadFogState(campaignId: string): Promise<Map<string, Set<string>>>` — query hex_visibility for campaign, build Map<hexKey, Set<userId>> where "__all__" sentinel becomes all-player marker. Return the map.
       - `loadMapData(campaignId: string): Promise<Map<string, { terrain: string, terrainVariant: number }>>` — query campaign_hex for campaign, return Map<hexKey, data>.

    2. Update `SessionRoom` interface in session-manager.ts:
       - Add `mapData: Map<string, { terrain: string; terrainVariant: number }>` field to SessionRoom.
       - Initialize as `new Map()` in getOrCreateRoom.
       - Add methods: `setMapData(campaignId, data)` and `getMapData(campaignId)` to SessionManager.
  </action>
  <verify>
    `cd packages/server && pnpm tsc --noEmit` compiles cleanly. Unit-test-level check: the adjacency logic is straightforward (same as client's), focus on compile verification.
  </verify>
  <done>fog-utils.ts exports adjacency computation and DB loading functions. SessionRoom tracks mapData.</done>
</task>

<task type="auto">
  <name>Task 2: Update message handlers and WS connect for fog enforcement</name>
  <files>
    packages/server/src/ws/message-handlers.ts
    packages/server/src/ws/handler.ts
  </files>
  <action>
    1. In `message-handlers.ts`:
       - Add "hex:hide" to the `isDmOnly` set.
       - Add case "hex:hide" in the dispatch switch, calling `handleHexHide`.
       - Update `handleHexReveal`:
         a. After updating in-memory revealedHexes, persist to DB: insert into hexVisibility (id=randomUUID, campaignId, hexKey, userId="__all__" or specific playerIds, revealedBy=userId, revealedAt=now). Use db.insert with onConflictDoNothing on the unique constraint.
         b. Build terrain data from room.mapData instead of placeholder "revealed".
         c. Compute adjacentHexes using `buildPlayerFogPayload` and include in the hex:revealed payload.
       - Create `handleHexHide`:
         a. Remove hex keys from room.revealedHexes (delete from Map or remove user from Set).
         b. Delete from hexVisibility DB table (matching campaignId + hexKey + userId filter).
         c. Broadcast `{ type: "hex:hidden", hexKeys }` to affected players.
         d. Log session event with type "hex_hide".

    2. In `handler.ts` onOpen:
       - After getting room, load fog state and map data if not already cached:
         ```
         if (room.revealedHexes.size === 0 && room is new) {
           room.revealedHexes = await loadFogState(campaignId);
           room.mapData = await loadMapData(campaignId);
         }
         ```
       - For DM: send session:state with ALL revealedHexes keys and full map data reference (DM client already has local map, but send revealedHexes so DM knows what players see).
       - For players: use `buildPlayerFogPayload` to compute what this player can see. The session:state message should include only revealed hex keys AND adjacentHexes with terrain-only data. Do NOT send terrain for unrevealed hexes.
       - The player's "all" reveals: when building player's revealed set, include hexes where viewers set contains the userId OR contains "__all__".
       - Include `adjacentHexes` field in the session:state payload sent to players.
  </action>
  <verify>
    `cd packages/server && pnpm tsc --noEmit` compiles. Start the server, connect as DM — session:state includes revealedHexes. Connect as player — session:state only includes filtered data with adjacentHexes.
  </verify>
  <done>Reveal persists to DB and broadcasts with terrain. Hide removes from DB and broadcasts hex:hidden. Players on connect receive ONLY revealed + adjacent terrain (FOG-05). DM receives full state.</done>
</task>

</tasks>

<verification>
1. `cd packages/server && pnpm tsc --noEmit` — passes
2. Start server, DM reveals hexes → hex_visibility rows created in DB
3. DM hides hexes → hex_visibility rows deleted
4. Player connects → session:state contains only their revealed hex keys + adjacentHexes terrain
5. Player does NOT receive terrain for unrevealed, non-adjacent hexes (inspect WS messages)
6. Server restart → reconnect → fog state loaded from DB correctly
</verification>

<success_criteria>
- handleHexReveal persists to hex_visibility and includes terrain from mapData
- handleHexHide removes from DB and broadcasts hex:hidden
- Player session:state is filtered: only revealed + adjacent terrain sent
- DM session:state includes all revealed hex keys
- Fog state survives server restart (loaded from DB)
</success_criteria>

<output>
After completion, create `.planning/phases/04-fog-of-war/04-02-SUMMARY.md`
</output>
