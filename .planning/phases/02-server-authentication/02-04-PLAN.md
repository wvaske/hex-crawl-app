---
phase: 02-server-authentication
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - packages/server/src/routes/invitations.ts
  - packages/server/src/app.ts
  - packages/client/src/lib/api.ts
  - packages/client/src/components/campaigns/CampaignList.tsx
  - packages/client/src/components/campaigns/CreateCampaignDialog.tsx
  - packages/client/src/components/campaigns/CampaignDashboard.tsx
  - packages/client/src/components/campaigns/InvitePlayerDialog.tsx
  - packages/client/src/components/campaigns/PendingInvitations.tsx
  - packages/client/src/App.tsx
autonomous: false

must_haves:
  truths:
    - "DM can create a campaign by entering a name in the UI"
    - "DM can see a list of their campaigns after logging in"
    - "DM can invite a player by entering their email address"
    - "Invited player sees pending invitations after logging in"
    - "Player can accept an invitation and join the campaign"
    - "Player can decline an invitation"
    - "Campaign and invitation data persists across browser sessions"
    - "Player cannot perform DM-only actions (create campaign invitations for campaigns they are not DM of)"
  artifacts:
    - path: "packages/server/src/routes/invitations.ts"
      provides: "Invitation CRUD: create, list pending, accept, decline"
      contains: "invitation"
    - path: "packages/client/src/components/campaigns/CampaignList.tsx"
      provides: "Campaign list view showing user's campaigns"
      contains: "campaigns"
    - path: "packages/client/src/components/campaigns/CreateCampaignDialog.tsx"
      provides: "Dialog form for creating a new campaign"
      contains: "name"
    - path: "packages/client/src/components/campaigns/InvitePlayerDialog.tsx"
      provides: "Dialog form for inviting a player by email"
      contains: "email"
    - path: "packages/client/src/components/campaigns/PendingInvitations.tsx"
      provides: "List of pending invitations with accept/decline buttons"
      contains: "accept"
    - path: "packages/client/src/lib/api.ts"
      provides: "API helper for authenticated fetch to server endpoints"
      contains: "fetch"
  key_links:
    - from: "packages/client/src/components/campaigns/CreateCampaignDialog.tsx"
      to: "POST /api/campaigns"
      via: "fetch with credentials"
      pattern: "api/campaigns"
    - from: "packages/client/src/components/campaigns/InvitePlayerDialog.tsx"
      to: "POST /api/campaigns/:id/invitations"
      via: "fetch with credentials"
      pattern: "api/campaigns.*invitations"
    - from: "packages/client/src/components/campaigns/PendingInvitations.tsx"
      to: "GET /api/invitations/pending"
      via: "fetch with credentials"
      pattern: "api/invitations"
    - from: "packages/server/src/routes/invitations.ts"
      to: "packages/server/src/db/schema/invitation.ts"
      via: "db.insert(invitation) and db.update(invitation)"
      pattern: "db\\.(insert|update)"
    - from: "packages/server/src/app.ts"
      to: "packages/server/src/routes/invitations.ts"
      via: "app.route('/api', invitations)"
      pattern: "app\\.route"
---

<objective>
Add invitation routes on the server and build the complete client UI for campaigns and invitations -- creating campaigns, inviting players, viewing and accepting invitations.

Purpose: This completes the full auth+campaign+invitation flow. After this plan, a DM can create a campaign, invite players, and those players can accept and join -- fulfilling AUTH-03 through AUTH-06.
Output: Working end-to-end flow: login -> see campaigns -> create campaign -> invite player -> player logs in -> sees invitation -> accepts -> joins campaign.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-authentication/02-RESEARCH.md
@.planning/phases/02-server-authentication/02-01-SUMMARY.md
@.planning/phases/02-server-authentication/02-02-SUMMARY.md
@.planning/phases/02-server-authentication/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invitation routes and mount on server</name>
  <files>
    packages/server/src/routes/invitations.ts
    packages/server/src/app.ts
  </files>
  <action>
1. Create `packages/server/src/routes/invitations.ts`:
   - Import Hono, zValidator, z, eq, and, db, campaign, campaignMember, invitation, requireAuth
   - Use the same AppVariables type pattern as campaigns.ts

   Define these routes (all require auth via `requireAuth` middleware):

   a. **POST /campaigns/:campaignId/invitations** -- DM invites a player by email:
      - Validate body: `{ email: z.string().email() }`
      - Get campaignId from URL param
      - Verify the authenticated user is a DM of this campaign:
        Query `campaignMember` where `campaignId = param AND userId = user.id AND role = "dm"`
      - If not DM, return `c.json({ error: "Forbidden: only DMs can invite players" }, 403)`
      - Check if invitation already exists (same campaign + email + status "pending"):
        If exists, return `c.json({ error: "Invitation already pending for this email" }, 409)`
      - Insert new invitation with id = crypto.randomUUID(), status = "pending"
      - Return `c.json({ invitation: { id, email, status } }, 201)`

   b. **GET /invitations/pending** -- List current user's pending invitations:
      - Get authenticated user's email from `c.get("user")!.email`
      - Query invitations where `email = user.email AND status = "pending"`
      - Join with campaign table to include campaign name
      - Return `c.json({ invitations: [...] })` with id, campaignId, campaignName, invitedBy, createdAt

   c. **POST /invitations/:id/accept** -- Accept an invitation:
      - Get invitation by ID where `email = user.email AND status = "pending"`
      - If not found, return 404
      - Use `db.transaction()` to:
        a. Update invitation status to "accepted"
        b. Insert into campaignMember with role = "player"
      - Return `c.json({ campaignId, role: "player" })`

   d. **POST /invitations/:id/decline** -- Decline an invitation:
      - Get invitation by ID where `email = user.email AND status = "pending"`
      - If not found, return 404
      - Update invitation status to "declined"
      - Return `c.json({ success: true })`

   Export the router.

2. Mount invitation routes in `packages/server/src/app.ts`:
   - Define full paths inside invitations.ts (routes a-d above use full paths like `/campaigns/:campaignId/invitations` and `/invitations/pending`).
   - Mount at `/api` root: `app.route("/api", invitations)`
   - This does NOT conflict with `app.route("/api/campaigns", campaigns)` because Hono matches routes by specificity -- `/api/campaigns/:campaignId/invitations` is more specific than `/api/campaigns/:id` and will match first.
   - The resulting URL structure:
     - `POST /api/campaigns/:campaignId/invitations` (from invitations router)
     - `GET /api/invitations/pending` (from invitations router)
     - `POST /api/invitations/:id/accept` (from invitations router)
     - `POST /api/invitations/:id/decline` (from invitations router)
     - `POST /api/campaigns` (from campaigns router -- no conflict)
     - `GET /api/campaigns` (from campaigns router -- no conflict)
  </action>
  <verify>
    Start server: `cd packages/server && npx tsx src/index.ts &`

    1. Sign up two users (DM and Player):
       ```bash
       curl -s -X POST http://localhost:3000/api/auth/sign-up/email -H "Content-Type: application/json" -d '{"name":"DM","email":"dm@test.com","password":"password123"}' -c /tmp/dm_cookies.txt
       curl -s -X POST http://localhost:3000/api/auth/sign-up/email -H "Content-Type: application/json" -d '{"name":"Player","email":"player@test.com","password":"password123"}' -c /tmp/player_cookies.txt
       ```

    2. DM creates campaign:
       ```bash
       CAMPAIGN_ID=$(curl -s -X POST http://localhost:3000/api/campaigns -H "Content-Type: application/json" -d '{"name":"Test Campaign"}' -b /tmp/dm_cookies.txt | grep -o '"id":"[^"]*"' | cut -d'"' -f4)
       ```

    3. DM invites player:
       ```bash
       curl -s -X POST "http://localhost:3000/api/campaigns/$CAMPAIGN_ID/invitations" -H "Content-Type: application/json" -d '{"email":"player@test.com"}' -b /tmp/dm_cookies.txt
       ```
       Should return 201 with invitation data.

    4. Player checks pending invitations:
       ```bash
       curl -s http://localhost:3000/api/invitations/pending -b /tmp/player_cookies.txt
       ```
       Should show the pending invitation.

    5. Player accepts:
       ```bash
       INVITE_ID=$(curl -s http://localhost:3000/api/invitations/pending -b /tmp/player_cookies.txt | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
       curl -s -X POST "http://localhost:3000/api/invitations/$INVITE_ID/accept" -b /tmp/player_cookies.txt
       ```
       Should return campaignId and role "player".

    6. Player now sees the campaign in their list:
       ```bash
       curl -s http://localhost:3000/api/campaigns -b /tmp/player_cookies.txt
       ```
       Should include the campaign with role "player".

    7. Role enforcement: Player cannot invite others:
       ```bash
       curl -s -X POST "http://localhost:3000/api/campaigns/$CAMPAIGN_ID/invitations" -H "Content-Type: application/json" -d '{"email":"other@test.com"}' -b /tmp/player_cookies.txt
       ```
       Should return 403 Forbidden.

    Kill server after verification.
  </verify>
  <done>
    DM can invite by email (POST /api/campaigns/:id/invitations with role check). Player can list pending invitations (GET /api/invitations/pending). Player can accept (POST /api/invitations/:id/accept creates campaign_member). Player can decline (POST /api/invitations/:id/decline). Role enforcement prevents players from inviting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build client campaign and invitation UI</name>
  <files>
    packages/client/src/lib/api.ts
    packages/client/src/components/campaigns/CampaignList.tsx
    packages/client/src/components/campaigns/CreateCampaignDialog.tsx
    packages/client/src/components/campaigns/CampaignDashboard.tsx
    packages/client/src/components/campaigns/InvitePlayerDialog.tsx
    packages/client/src/components/campaigns/PendingInvitations.tsx
    packages/client/src/App.tsx
  </files>
  <action>
1. Create `packages/client/src/lib/api.ts` -- API helper:
   ```typescript
   const API_URL = import.meta.env.VITE_API_URL || "http://localhost:3000";

   export async function apiFetch(path: string, options?: RequestInit) {
     const res = await fetch(`${API_URL}${path}`, {
       ...options,
       credentials: "include",
       headers: {
         "Content-Type": "application/json",
         ...options?.headers,
       },
     });
     if (!res.ok) {
       const body = await res.json().catch(() => ({}));
       throw new Error(body.error || `Request failed: ${res.status}`);
     }
     return res.json();
   }
   ```

2. Create `packages/client/src/components/campaigns/CampaignList.tsx`:
   - Fetch campaigns from GET /api/campaigns on mount (useEffect)
   - Display as a list/grid of campaign cards
   - Each card shows: campaign name, user's role (DM or Player badge), creation date
   - "Create Campaign" button (visible to all -- any user can be DM of their own campaigns)
   - Clicking a campaign navigates to CampaignDashboard (use state or simple routing)
   - Style: dark theme cards (bg-gray-800 rounded-lg p-4), role badges (blue for DM, green for Player)

3. Create `packages/client/src/components/campaigns/CreateCampaignDialog.tsx`:
   - Modal/dialog with campaign name input
   - POST /api/campaigns on submit
   - On success, refresh the campaign list
   - Close on success or cancel
   - Style: modal overlay with bg-gray-800 card, consistent with existing CreationDialog pattern

4. Create `packages/client/src/components/campaigns/CampaignDashboard.tsx`:
   - Shows selected campaign details (name, role)
   - If user is DM: show "Invite Player" button, show campaign members list
   - If user is Player: show campaign info, show other members
   - Fetch campaign details from GET /api/campaigns/:id
   - "Back to Campaigns" button to return to list
   - "Enter Map" button that navigates to the hex map (existing MapView)
   - For DMs: show InvitePlayerDialog trigger

5. Create `packages/client/src/components/campaigns/InvitePlayerDialog.tsx`:
   - Modal with email input
   - POST /api/campaigns/:id/invitations on submit
   - Show success/error messages
   - Only rendered for DM role users

6. Create `packages/client/src/components/campaigns/PendingInvitations.tsx`:
   - Fetch pending invitations from GET /api/invitations/pending
   - Show each invitation: campaign name, who invited, date
   - "Accept" and "Decline" buttons for each
   - Accept: POST /api/invitations/:id/accept, then refresh campaign list
   - Decline: POST /api/invitations/:id/decline, then remove from list
   - Show at the top of the campaign list page (banner/section) when invitations exist

7. Update `packages/client/src/App.tsx`:
   - After AuthGuard, show the campaign flow:
     - Default view: CampaignList (with PendingInvitations at top if any)
     - Campaign selected: CampaignDashboard
     - "Enter Map" from dashboard: existing MapView
   - Use simple state management for navigation between these views (useState with a "view" enum, or a simple context). Do NOT add a routing library -- keep it simple with conditional rendering:
     ```
     view = "campaigns" | "dashboard" | "map"
     selectedCampaignId: string | null
     ```
   - The existing MapView content should be accessible from within a campaign context
   - Preserve the logout button from Plan 03
  </action>
  <verify>
    1. `pnpm --filter @hex-crawl/client exec -- npx tsc --noEmit` passes
    2. Start both server and client
    3. Log in as a new user -> see empty campaign list with "Create Campaign" button
    4. Create a campaign -> it appears in the list with "DM" role badge
    5. Click campaign -> see CampaignDashboard with "Invite Player" button
    6. Invite a player email -> success message
    7. Log in as second user with that email -> see pending invitation banner
    8. Accept invitation -> campaign appears in list with "Player" role badge
    9. Click campaign as player -> see CampaignDashboard WITHOUT "Invite Player" button
    10. Click "Enter Map" -> see the hex map from Phase 1
  </verify>
  <done>
    Campaign list shows all user's campaigns with role badges. Create campaign dialog works. Campaign dashboard shows details and members. DM can invite players via email. Players see pending invitations and can accept/decline. "Enter Map" navigates to the hex map. Role-based UI: only DMs see invite controls.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete auth and campaign flow</name>
  <what-built>
    Full authentication and campaign management flow:
    - User signup and login with email/password
    - Session persistence across browser refreshes
    - Campaign creation by DM
    - Player invitation by email
    - Invitation acceptance/decline
    - Role-based UI (DM sees invite controls, player does not)
    - Navigation: campaigns list -> campaign dashboard -> hex map
    - All data persists in PostgreSQL
  </what-built>
  <how-to-verify>
    Ensure both server and client are running:
    - Server: `cd packages/server && pnpm dev` (port 3000)
    - Client: `cd packages/client && pnpm dev` (port 5173)

    **Test as DM:**
    1. Open the app in a browser -- you should see a login page
    2. Click "Sign Up" and create an account (name, email, password)
    3. After signup, you should be logged in and see the campaigns page
    4. Click "Create Campaign" and enter a campaign name
    5. The campaign should appear in your list with a "DM" badge
    6. Click the campaign to open its dashboard
    7. Click "Invite Player" and enter a second email address
    8. You should see a success message

    **Test as Player (second browser/incognito):**
    9. Open the app in an incognito window or different browser
    10. Sign up with the email you invited in step 7
    11. After signup, you should see a pending invitation at the top
    12. Click "Accept" -- the campaign should appear in your list with "Player" badge
    13. Click the campaign -- you should NOT see "Invite Player" button

    **Test persistence:**
    14. Close and reopen the browser (both windows)
    15. You should still be logged in (session cookie persists)
    16. Your campaigns should still be visible
    17. Click "Enter Map" from a campaign -- the hex map from Phase 1 should load

    **Test logout:**
    18. Click the logout button
    19. You should return to the login page
    20. Refresh -- you should still be on the login page (session cleared)
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 2, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. DM can invite player by email via the UI
2. Player sees pending invitations after login
3. Player can accept/decline invitations
4. Campaign list shows correct role badges
5. DM-only controls (invite) hidden from players
6. "Enter Map" loads the hex map from Phase 1
7. All data persists across browser close/reopen
8. Role enforcement works server-side (player cannot call DM endpoints)
</verification>

<success_criteria>
- Complete end-to-end flow: signup -> create campaign -> invite player -> player accepts -> both see campaign
- Campaign data and invitations persist in PostgreSQL
- Role-based access control enforced on both server and client
- Navigation between campaign list, dashboard, and hex map works
- Human verification confirms the full flow works in the browser
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-authentication/02-04-SUMMARY.md`
</output>
