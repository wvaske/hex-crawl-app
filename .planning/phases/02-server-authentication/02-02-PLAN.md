---
phase: 02-server-authentication
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/server/src/db/schema/campaign.ts
  - packages/server/src/db/schema/invitation.ts
  - packages/server/src/db/schema/index.ts
  - packages/server/src/middleware/auth.ts
  - packages/server/src/routes/campaigns.ts
  - packages/server/src/app.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated user can create a campaign via POST /api/campaigns"
    - "Authenticated user can list their campaigns via GET /api/campaigns"
    - "Campaign creator is automatically added as DM member"
    - "Unauthenticated requests to campaign routes return 401"
    - "Campaign data persists in PostgreSQL campaign table"
  artifacts:
    - path: "packages/server/src/db/schema/campaign.ts"
      provides: "campaign and campaign_member table definitions"
      contains: "pgTable"
    - path: "packages/server/src/db/schema/invitation.ts"
      provides: "invitation table definition"
      contains: "pgTable"
    - path: "packages/server/src/middleware/auth.ts"
      provides: "requireAuth middleware extracting session from Better Auth"
      contains: "createMiddleware"
    - path: "packages/server/src/routes/campaigns.ts"
      provides: "Campaign CRUD routes with Zod validation"
      contains: "zValidator"
  key_links:
    - from: "packages/server/src/routes/campaigns.ts"
      to: "packages/server/src/db/schema/campaign.ts"
      via: "db.insert(campaign) and db.select().from(campaignMember)"
      pattern: "db\\.(insert|select)"
    - from: "packages/server/src/routes/campaigns.ts"
      to: "packages/server/src/middleware/auth.ts"
      via: "requireAuth middleware on all routes"
      pattern: "requireAuth"
    - from: "packages/server/src/app.ts"
      to: "packages/server/src/routes/campaigns.ts"
      via: "app.route('/api/campaigns', campaigns)"
      pattern: "app\\.route"
---

<objective>
Define the application database schema (campaign, campaign_member, invitation tables) and create authenticated campaign CRUD routes with role enforcement.

Purpose: This provides the data model and API endpoints for campaign management. The DM needs to create campaigns and be assigned the DM role before invitations and client UI can work.
Output: Campaign and invitation Drizzle schemas pushed to PostgreSQL, plus POST/GET /api/campaigns routes behind auth middleware.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-authentication/02-RESEARCH.md
@.planning/phases/02-server-authentication/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create application schema (campaign, campaign_member, invitation) and push to database</name>
  <files>
    packages/server/src/db/schema/campaign.ts
    packages/server/src/db/schema/invitation.ts
    packages/server/src/db/schema/index.ts
  </files>
  <action>
1. Create `packages/server/src/db/schema/campaign.ts`:
   - Import `pgTable`, `text`, `timestamp` from `drizzle-orm/pg-core`
   - Import `user` from `./auth.js` (the Better Auth user table)
   - Define `campaign` table:
     - `id`: text, primaryKey (use crypto.randomUUID() at insert time)
     - `name`: text, notNull
     - `ownerId`: text("owner_id"), notNull, references(() => user.id, { onDelete: "cascade" })
     - `createdAt`: timestamp("created_at"), defaultNow(), notNull
     - `updatedAt`: timestamp("updated_at"), defaultNow(), notNull
   - Define `campaignMember` table:
     - `id`: text, primaryKey
     - `campaignId`: text("campaign_id"), notNull, references(() => campaign.id, { onDelete: "cascade" })
     - `userId`: text("user_id"), notNull, references(() => user.id, { onDelete: "cascade" })
     - `role`: text("role", { enum: ["dm", "player"] }), notNull
     - `joinedAt`: timestamp("joined_at"), defaultNow(), notNull
   - Export both `campaign` and `campaignMember`

2. Create `packages/server/src/db/schema/invitation.ts`:
   - Import `pgTable`, `text`, `timestamp` from `drizzle-orm/pg-core`
   - Import `campaign` from `./campaign.js`
   - Import `user` from `./auth.js`
   - Define `invitation` table:
     - `id`: text, primaryKey
     - `campaignId`: text("campaign_id"), notNull, references(() => campaign.id, { onDelete: "cascade" })
     - `email`: text("email"), notNull
     - `invitedBy`: text("invited_by"), notNull, references(() => user.id)
     - `status`: text("status", { enum: ["pending", "accepted", "declined"] }), notNull, default("pending")
     - `createdAt`: timestamp("created_at"), defaultNow(), notNull
     - `expiresAt`: timestamp("expires_at")
   - Export `invitation`

3. Update `packages/server/src/db/schema/index.ts`:
   - Add `export * from "./campaign.js"`
   - Add `export * from "./invitation.js"`

4. Push schema to database:
   ```bash
   cd packages/server && npx drizzle-kit push
   ```

5. Verify tables exist:
   ```bash
   sudo -u postgres psql -d hexcrawl_dev -c "\dt"
   ```
   Should show: user, session, account, verification (from auth), campaign, campaign_member, invitation (from application).
  </action>
  <verify>
    Run `sudo -u postgres psql -d hexcrawl_dev -c "\dt"` and confirm all 7 tables exist (user, session, account, verification, campaign, campaign_member, invitation).
    Run `sudo -u postgres psql -d hexcrawl_dev -c "\d campaign"` and confirm columns: id, name, owner_id, created_at, updated_at.
    Run `sudo -u postgres psql -d hexcrawl_dev -c "\d campaign_member"` and confirm columns: id, campaign_id, user_id, role, joined_at.
    Run `sudo -u postgres psql -d hexcrawl_dev -c "\d invitation"` and confirm columns: id, campaign_id, email, invited_by, status, created_at, expires_at.
  </verify>
  <done>
    All 7 database tables exist in PostgreSQL with correct columns and foreign key relationships. Schema barrel export includes auth, campaign, and invitation modules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth middleware and campaign CRUD routes</name>
  <files>
    packages/server/src/middleware/auth.ts
    packages/server/src/routes/campaigns.ts
    packages/server/src/app.ts
  </files>
  <action>
1. Create `packages/server/src/middleware/auth.ts`:
   - Import `createMiddleware` from `hono/factory`
   - Import `auth` from `../auth.js`
   - Export `authMiddleware`: extracts session via `auth.api.getSession({ headers: c.req.raw.headers })`, sets `c.set("user", ...)` and `c.set("session", ...)`, calls `next()`. Sets null if no session.
   - Export `requireAuth`: same as authMiddleware but returns `c.json({ error: "Unauthorized" }, 401)` if no session.

2. Create `packages/server/src/routes/campaigns.ts`:
   - Import Hono, zValidator, z, eq, and, db, campaign, campaignMember, requireAuth
   - Create `const campaigns = new Hono()` -- do NOT parameterize with AppVariables here (it inherits from parent when mounted via app.route)
     Actually, to access c.get("user") with type safety, parameterize with the same Variables type:
     ```typescript
     import type { AppVariables } from "../app.js";
     const campaigns = new Hono<{ Variables: AppVariables }>()
     ```
   - Apply `requireAuth` to all routes: `.use("*", requireAuth)`
   - POST `/` -- Create campaign:
     - Validate body with `zValidator("json", z.object({ name: z.string().min(1).max(100) }))`
     - Get user from `c.get("user")!`
     - Generate `id` via `crypto.randomUUID()`
     - Use `db.transaction()` to:
       a. Insert into `campaign` with id, name, ownerId = user.id
       b. Insert into `campaignMember` with id = crypto.randomUUID(), campaignId = id, userId = user.id, role = "dm"
     - Return `c.json({ id, name, ownerId: user.id }, 201)`
   - GET `/` -- List user's campaigns:
     - Get user from `c.get("user")!`
     - Query: `db.select().from(campaignMember).innerJoin(campaign, eq(campaign.id, campaignMember.campaignId)).where(eq(campaignMember.userId, user.id))`
     - Map results to `{ id, name, ownerId, role, createdAt }` objects
     - Return `c.json({ campaigns: [...] })`
   - GET `/:id` -- Get single campaign (verify membership):
     - Get campaignId from `c.req.param("id")`
     - Query campaignMember for this user + campaign
     - If not found, return 404
     - Return campaign data with user's role
   - Export `default campaigns`

3. Export `AppVariables` type from `packages/server/src/app.ts`:
   - Change `type AppVariables` to `export type AppVariables`

4. Mount campaign routes in `packages/server/src/app.ts`:
   - Import `campaigns` from `./routes/campaigns.js`
   - Add `app.route("/api/campaigns", campaigns)` AFTER the auth handler mount
  </action>
  <verify>
    Start server: `cd packages/server && npx tsx src/index.ts &`

    1. Unauthenticated request returns 401:
       `curl -s http://localhost:3000/api/campaigns | grep -q "Unauthorized"`

    2. Sign up a user:
       `curl -s -X POST http://localhost:3000/api/auth/sign-up/email -H "Content-Type: application/json" -d '{"name":"DM User","email":"dm@test.com","password":"password123"}' -c /tmp/cookies.txt`

    3. Create a campaign (using session cookie):
       `curl -s -X POST http://localhost:3000/api/campaigns -H "Content-Type: application/json" -d '{"name":"Test Campaign"}' -b /tmp/cookies.txt`
       Should return 201 with campaign id and name.

    4. List campaigns:
       `curl -s http://localhost:3000/api/campaigns -b /tmp/cookies.txt`
       Should return the created campaign with role "dm".

    5. Verify in database:
       `sudo -u postgres psql -d hexcrawl_dev -c "SELECT name FROM campaign"`
       Should show "Test Campaign".

    Kill server process after verification.
  </verify>
  <done>
    requireAuth middleware rejects unauthenticated requests with 401. Campaign POST creates a campaign and adds the creator as DM member in a single transaction. Campaign GET lists all campaigns the user belongs to with their role. Campaign data persists in PostgreSQL.
  </done>
</task>

</tasks>

<verification>
1. All 7 database tables exist with correct foreign key relationships
2. requireAuth middleware blocks unauthenticated requests
3. POST /api/campaigns creates campaign + DM member atomically
4. GET /api/campaigns returns user's campaigns with roles
5. GET /api/campaigns/:id returns single campaign for members, 404 for non-members
</verification>

<success_criteria>
- Application schema (campaign, campaign_member, invitation) defined and pushed to PostgreSQL
- Auth middleware extracts session and rejects unauthenticated requests
- Campaign CRUD routes work end-to-end (create, list, get by ID)
- Campaign creator is automatically added as DM
- All operations persist in PostgreSQL
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-authentication/02-02-SUMMARY.md`
</output>
