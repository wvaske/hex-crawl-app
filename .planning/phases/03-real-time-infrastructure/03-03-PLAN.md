---
phase: 03-real-time-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/client/src/stores/useSessionStore.ts
  - packages/client/src/hooks/useWebSocket.ts
  - packages/client/src/components/ConnectionBanner.tsx
  - packages/client/src/components/SessionOverlay.tsx
autonomous: true

must_haves:
  truths:
    - "Client connects to WebSocket at /ws?campaignId=X with automatic cookie-based auth"
    - "Connection loss shows persistent banner 'Connection lost. Reconnecting...' that auto-dismisses on reconnect"
    - "Client reconnects automatically with exponential backoff and jitter (1s initial, 30s max, 75-125% jitter)"
    - "Session state (status, broadcast mode, players, connection status) is managed in Zustand store"
    - "Players see 'Waiting for DM...' overlay when session status is 'waiting'"
    - "Players see 'Session Paused' grey overlay when session is paused"
    - "Players see frozen read-only state when session is ended"
  artifacts:
    - path: "packages/client/src/stores/useSessionStore.ts"
      provides: "Zustand store for real-time session state with message dispatch"
      exports: ["useSessionStore"]
    - path: "packages/client/src/hooks/useWebSocket.ts"
      provides: "React hook managing WebSocket lifecycle, reconnection, and store dispatch"
      exports: ["useWebSocket"]
    - path: "packages/client/src/components/ConnectionBanner.tsx"
      provides: "Persistent top banner for connection loss/reconnecting status"
      exports: ["ConnectionBanner"]
    - path: "packages/client/src/components/SessionOverlay.tsx"
      provides: "Full-screen overlays for waiting/paused/ended session states"
      exports: ["SessionOverlay"]
  key_links:
    - from: "packages/client/src/hooks/useWebSocket.ts"
      to: "packages/client/src/stores/useSessionStore.ts"
      via: "ws.onmessage dispatches parsed ServerMessage to store"
      pattern: "dispatch\\(message\\)"
    - from: "packages/client/src/components/ConnectionBanner.tsx"
      to: "packages/client/src/stores/useSessionStore.ts"
      via: "Reads connectionStatus to show/hide banner"
      pattern: "useSessionStore.*connectionStatus"
    - from: "packages/client/src/components/SessionOverlay.tsx"
      to: "packages/client/src/stores/useSessionStore.ts"
      via: "Reads sessionStatus and userRole to determine overlay"
      pattern: "useSessionStore.*sessionStatus"
---

<objective>
Build the client-side real-time infrastructure: a Zustand session store, WebSocket connection hook with reconnection, and UI feedback components for connection status and session lifecycle states.

Purpose: Players and DMs need a reactive client that connects to the server's WebSocket, dispatches incoming messages to a store, reconnects automatically on disconnection, and shows appropriate overlays based on session state. This is the client half of the real-time system.

Output: A useWebSocket hook, useSessionStore Zustand store, ConnectionBanner component, and SessionOverlay component -- all independently usable and ready for integration in Plan 04.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-infrastructure/03-RESEARCH.md
@.planning/phases/03-real-time-infrastructure/03-01-SUMMARY.md

# Key existing files
@packages/client/src/stores/useMapStore.ts
@packages/client/src/stores/useUIStore.ts
@packages/client/src/App.tsx
@packages/shared/src/ws-messages.ts
@packages/shared/src/session-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSessionStore and useWebSocket hook</name>
  <files>
    packages/client/src/stores/useSessionStore.ts
    packages/client/src/hooks/useWebSocket.ts
  </files>
  <action>
1. Create `packages/client/src/stores/useSessionStore.ts`:
   - Import `create` from 'zustand'
   - Import types from shared package: `ServerMessage`, `ConnectionStatus`, `SessionStatus`, `BroadcastMode`, `PlayerPresence`, `StagedChange`

   **State interface:**
   ```typescript
   interface SessionState {
     // Connection
     connectionStatus: ConnectionStatus  // 'disconnected' | 'connecting' | 'connected' | 'reconnecting'

     // Session
     sessionStatus: SessionStatus        // 'waiting' | 'active' | 'paused' | 'ended'
     broadcastMode: BroadcastMode        // 'immediate' | 'staged'
     userRole: 'dm' | 'player' | null
     userId: string | null

     // Players
     connectedPlayers: Map<string, PlayerPresence>

     // DM-specific
     stagedChanges: StagedChange[]
     dmPreparing: boolean               // shown to players in staged mode

     // Revealed hexes (Phase 4 will populate; store the keys now)
     revealedHexKeys: Set<string>
   }
   ```

   **Actions interface:**
   ```typescript
   interface SessionActions {
     setConnectionStatus: (status: ConnectionStatus) => void
     dispatch: (message: ServerMessage) => void
     reset: () => void
     sendMessage: ((msg: ClientMessage) => void) | null  // set by useWebSocket hook
     setSendMessage: (fn: (msg: ClientMessage) => void) => void
   }
   ```

   **dispatch implementation** -- switch on message.type:
   - `connected`: set userRole and userId from message data
   - `session:state`: set sessionStatus, broadcastMode, update connectedPlayers (create NEW Map), set revealedHexKeys (create NEW Set)
   - `session:statusChanged`: set sessionStatus
   - `player:joined`: add to connectedPlayers (create NEW Map from existing + new entry)
   - `player:left`: remove from connectedPlayers (create NEW Map without the userId)
   - `player:presence`: replace entire connectedPlayers with new Map from array
   - `dm:preparing`: set dmPreparing boolean
   - `staged:changes`: set stagedChanges array (DM only)
   - `hex:revealed`: add hex keys to revealedHexKeys (create NEW Set with spread + new keys)
   - `hex:updated`: (store update for Phase 4)
   - `error`: console.error the message

   **IMPORTANT (existing pattern):** Always create new Map/Set instances for reactivity. Never mutate existing Map/Set. This is an established codebase pattern (see useMapStore.ts "PITFALL 6" comments).

   **reset():** Reset all state to initial values (for cleanup on disconnect/campaign change).

   **Initial state:** connectionStatus 'disconnected', sessionStatus 'waiting', broadcastMode 'immediate', null role/userId, empty Map/Set, empty stagedChanges, dmPreparing false.

2. Create `packages/client/src/hooks/useWebSocket.ts`:
   - Import useEffect, useRef, useCallback from 'react'
   - Import useSessionStore
   - Import ClientMessage type from shared

   **Constants:**
   ```typescript
   const INITIAL_DELAY = 1000
   const MAX_DELAY = 30000
   const BACKOFF_MULTIPLIER = 2
   ```

   **Hook: `useWebSocket(campaignId: string | null)`:**
   - `wsRef = useRef<WebSocket | null>(null)`
   - `retryCountRef = useRef(0)`
   - `reconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null)`
   - Get `dispatch`, `setConnectionStatus`, `setSendMessage`, `reset` from useSessionStore

   **connect function (useCallback):**
   - If !campaignId, return
   - Set connectionStatus to 'connecting'
   - Determine protocol: `ws:` or `wss:` based on window.location.protocol
   - Create WebSocket: `new WebSocket(\`${protocol}//${window.location.host}/ws?campaignId=${campaignId}\`)`

   **ws.onopen:**
   - retryCount = 0
   - setConnectionStatus('connected')

   **ws.onmessage:**
   - Parse JSON
   - Call dispatch(message)

   **ws.onerror:**
   - Console.warn the error

   **ws.onclose:**
   - setConnectionStatus('reconnecting')
   - Compute delay: `Math.min(INITIAL_DELAY * BACKOFF_MULTIPLIER ** retryCountRef.current, MAX_DELAY)`
   - Add jitter: `delay * (0.75 + Math.random() * 0.5)`
   - Increment retryCount
   - Set reconnect timer: `reconnectTimerRef.current = setTimeout(connect, jitteredDelay)`

   **setSendMessage callback:**
   - After connection, set sendMessage on the store:
     ```typescript
     const send = (msg: ClientMessage) => {
       if (wsRef.current?.readyState === WebSocket.OPEN) {
         wsRef.current.send(JSON.stringify(msg))
       }
     }
     setSendMessage(send)
     ```
   - Call this in onopen handler

   **useEffect:**
   - Call connect() when campaignId changes
   - Cleanup: close existing ws, clear reconnect timer, reset store

   **Return:** wsRef (for external access if needed)
  </action>
  <verify>
1. `cd packages/client && pnpm tsc --noEmit` compiles without errors
2. Store exports useSessionStore with all state fields and actions
3. Hook exports useWebSocket with campaignId parameter
  </verify>
  <done>
useSessionStore manages all real-time session state with reactive Map/Set updates. useWebSocket connects to /ws with campaignId, dispatches server messages to store, handles reconnection with exponential backoff + jitter, and exposes sendMessage for outbound messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ConnectionBanner and SessionOverlay UI components</name>
  <files>
    packages/client/src/components/ConnectionBanner.tsx
    packages/client/src/components/SessionOverlay.tsx
  </files>
  <action>
1. Create `packages/client/src/components/ConnectionBanner.tsx`:
   - Import useSessionStore
   - Read connectionStatus from store

   **Render logic:**
   - If connectionStatus is 'connected' or 'disconnected': return null (no banner)
   - If connectionStatus is 'connecting': show "Connecting..." banner
   - If connectionStatus is 'reconnecting': show "Connection lost. Reconnecting..." banner

   **Styling (Tailwind dark theme, matching codebase conventions):**
   - Fixed position at top of viewport: `fixed top-0 left-0 right-0 z-[100]`
   - Background: `bg-yellow-600/90` for connecting, `bg-red-600/90` for reconnecting
   - Text: `text-white text-sm text-center py-2 px-4`
   - Subtle animation: `animate-pulse` on the text or a small spinner icon
   - The banner should not push content down -- it overlays
   - Include a small spinning indicator (CSS animation or simple SVG)

2. Create `packages/client/src/components/SessionOverlay.tsx`:
   - Import useSessionStore
   - Read sessionStatus and userRole from store

   **Render logic -- different overlays based on sessionStatus:**

   **'waiting' (only for players -- DM sees the dashboard controls):**
   - If userRole === 'player' and sessionStatus === 'waiting':
   - Full-screen overlay: `fixed inset-0 z-[90] flex items-center justify-center`
   - Semi-transparent background: `bg-gray-900/80 backdrop-blur-sm`
   - Central card: "Waiting for DM to start the session..."
   - Subtle pulsing animation on the text
   - Dark theme styling: `bg-gray-800 text-gray-200 border border-gray-700 rounded-lg p-8`

   **'paused' (all roles see this):**
   - Full-screen grey overlay: `fixed inset-0 z-[90] flex items-center justify-center`
   - Background: `bg-gray-900/70 backdrop-blur-sm`
   - Central card: "Session Paused"
   - Subtitle: "The DM has paused the session. Please wait..."
   - Styling: same card style as waiting state

   **'ended':**
   - If userRole === 'player':
   - Subtle top banner (not full overlay): `fixed top-0 left-0 right-0 z-[90]`
   - Background: `bg-gray-700/90`
   - Text: "Session ended. Map is read-only."
   - Players can still look around but no live updates

   **'active':**
   - Return null (no overlay)

   **DM 'preparing' indicator (for players only):**
   - Read dmPreparing from store
   - If dmPreparing && userRole === 'player' && sessionStatus === 'active':
   - Small subtle indicator at bottom-right: `fixed bottom-4 right-4 z-[80]`
   - Small pill badge: "DM is preparing..." with a subtle pulse
   - Styling: `bg-gray-800/80 text-gray-400 text-xs px-3 py-1.5 rounded-full border border-gray-700`
   - This should be subtle (context: "DM is preparing..." indicator should not distract from gameplay)
  </action>
  <verify>
1. `cd packages/client && pnpm tsc --noEmit` compiles without errors
2. ConnectionBanner renders nothing when connected
3. SessionOverlay renders waiting state for players
4. Both components use Tailwind classes consistent with existing dark theme (bg-gray-800/700/900, text-gray-100/200/300)
  </verify>
  <done>
ConnectionBanner shows a persistent, non-pushing overlay banner for 'connecting' and 'reconnecting' states. SessionOverlay shows appropriate full-screen overlays for 'waiting' (players only), 'paused' (all), and 'ended' (banner for players). DM-preparing indicator shows a subtle bottom-right pill badge. All styled with Tailwind dark theme matching codebase conventions.
  </done>
</task>

</tasks>

<verification>
1. Client compiles: `cd packages/client && pnpm tsc --noEmit`
2. useSessionStore.dispatch correctly updates state for each ServerMessage type
3. useWebSocket connects to /ws and dispatches messages to store
4. ConnectionBanner shows/hides based on connectionStatus
5. SessionOverlay shows correct state for each sessionStatus
</verification>

<success_criteria>
- Zustand session store reactively manages connection status, session state, player presence, staged changes, and revealed hexes with proper Map/Set reactivity
- WebSocket hook connects, reconnects with backoff+jitter, and dispatches to store
- ConnectionBanner overlays on connection loss and auto-dismisses on reconnect
- SessionOverlay shows waiting/paused/ended states appropriately per role
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-infrastructure/03-03-SUMMARY.md`
</output>
