---
phase: 03-real-time-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/server/src/ws/session-manager.ts
  - packages/server/src/ws/message-handlers.ts
  - packages/server/src/ws/handler.ts
autonomous: true

must_haves:
  truths:
    - "DM can start, pause, resume, and end a session via WebSocket messages"
    - "Server tracks connected clients per campaign room with userId, role, and WebSocket reference"
    - "Broadcast sends messages to all room clients, with optional role or player ID filtering"
    - "DM toggling broadcast mode between immediate and staged is reflected in the session room state"
    - "Session lifecycle events (start, pause, resume, end, player join/leave) are logged to session_event table"
    - "Staged changes accumulate and can be undone individually before DM publishes them"
  artifacts:
    - path: "packages/server/src/ws/session-manager.ts"
      provides: "SessionManager singleton with room CRUD, connection tracking, filtered broadcast"
      exports: ["sessionManager", "SessionManager", "SessionRoom", "ConnectedClient"]
    - path: "packages/server/src/ws/message-handlers.ts"
      provides: "Handler functions for each client message type, dispatching to SessionManager"
      exports: ["handleClientMessage"]
  key_links:
    - from: "packages/server/src/ws/handler.ts"
      to: "packages/server/src/ws/session-manager.ts"
      via: "onOpen calls sessionManager.addConnection, onClose calls removeConnection"
      pattern: "sessionManager\\.(add|remove)Connection"
    - from: "packages/server/src/ws/handler.ts"
      to: "packages/server/src/ws/message-handlers.ts"
      via: "onMessage calls handleClientMessage with parsed data"
      pattern: "handleClientMessage"
    - from: "packages/server/src/ws/message-handlers.ts"
      to: "packages/server/src/db/schema/session.ts"
      via: "Inserts session events into session_event table via Drizzle"
      pattern: "db\\.insert\\(sessionEvent\\)"
---

<objective>
Build the server-side session management system: an in-memory SessionManager that tracks campaign rooms with connected clients, handles DM session lifecycle commands, manages staged/immediate broadcast modes, and logs session events to PostgreSQL.

Purpose: This is the brain of the real-time system. The SessionManager holds all active campaign sessions, routes messages to the right clients based on role, and enforces DM-only actions. Without this, the WebSocket endpoint from Plan 01 is just a pipe with no logic.

Output: A fully functional SessionManager singleton and message handler that process all client-to-server message types, update room state, broadcast filtered updates, and persist events.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-infrastructure/03-RESEARCH.md
@.planning/phases/03-real-time-infrastructure/03-01-SUMMARY.md

# Key existing files after Plan 01
@packages/server/src/ws/setup.ts
@packages/server/src/ws/handler.ts
@packages/server/src/db/schema/session.ts
@packages/shared/src/ws-messages.ts
@packages/shared/src/session-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build SessionManager with room management, connection tracking, and filtered broadcast</name>
  <files>packages/server/src/ws/session-manager.ts</files>
  <action>
Create `packages/server/src/ws/session-manager.ts` with:

1. **Interfaces:**
   - `ConnectedClient`: `{ userId: string; name: string; role: 'dm' | 'player'; ws: WSContext }` (import WSContext from 'hono/ws')
   - `StagedChange`: `{ id: string; description: string; type: string; data: unknown }`
   - `SessionRoom`: `{ campaignId: string; sessionId: string | null; status: 'waiting' | 'active' | 'paused' | 'ended'; broadcastMode: 'immediate' | 'staged'; stagedChanges: StagedChange[]; connectedClients: Map<string, ConnectedClient>; revealedHexes: Map<string, Set<string>> }` (revealedHexes: hexKey -> Set of userIds who can see it)

2. **SessionManager class** (exported as singleton `sessionManager`):
   - `private rooms = new Map<string, SessionRoom>()`

   - `getOrCreateRoom(campaignId: string): SessionRoom` -- if room doesn't exist, create with status 'waiting', broadcastMode 'immediate', empty collections. Return existing or new room.

   - `addConnection(campaignId: string, userId: string, name: string, role: 'dm' | 'player', ws: WSContext): void`
     - Get or create room
     - Add client to connectedClients map (keyed by userId)
     - Broadcast `player:joined` message to all OTHER clients in room
     - Send `session:state` to the newly connected client with: status, broadcastMode, connectedPlayers list (map clients to {userId, name, online: true}), empty revealedHexes for now (Phase 4 will populate)
     - If role is 'dm' and broadcastMode is 'staged', also send `staged:changes` with current stagedChanges list

   - `removeConnection(campaignId: string, userId: string): void`
     - Remove from connectedClients
     - Broadcast `player:left` with userId to remaining clients
     - If room has 0 clients, optionally clean up (or leave for potential reconnect -- leave room for now, clean up after 5 minutes with setTimeout)

   - `broadcastToRoom(campaignId: string, message: object, filter?: (client: ConnectedClient) => boolean): void`
     - Get room, iterate connectedClients, JSON.stringify once, send to clients passing filter (or all if no filter)
     - Skip clients whose ws.readyState is not OPEN (readyState === 1)

   - `broadcastToDM(campaignId: string, message: object): void`
     - Filter: client.role === 'dm'

   - `broadcastToPlayers(campaignId: string, message: object, playerIds?: string[]): void`
     - Filter: client.role === 'player' AND (no playerIds filter OR userId in playerIds)

   - `broadcastToAll(campaignId: string, message: object): void`
     - No filter

   - `getRoom(campaignId: string): SessionRoom | undefined`

   - `getPresenceList(campaignId: string): Array<{ userId: string; name: string; online: boolean }>`
     - Return list of connected clients with online: true. (Future: track disconnected members too)

   - `setSessionStatus(campaignId: string, status: SessionRoom['status'], sessionId?: string): void`
     - Update room status
     - If status is 'active' and sessionId provided, set room.sessionId
     - If status is 'ended', set room.sessionId to null

   - `setBroadcastMode(campaignId: string, mode: 'immediate' | 'staged'): void`
     - Update room broadcastMode
     - If switching from staged to immediate, clear stagedChanges

   - `addStagedChange(campaignId: string, change: StagedChange): void`
     - Push to room.stagedChanges

   - `undoStagedChange(campaignId: string, index: number): StagedChange | null`
     - Remove and return the change at index (splice)

   - `clearStagedChanges(campaignId: string): StagedChange[]`
     - Clear and return all staged changes (for publish)

3. Export singleton: `export const sessionManager = new SessionManager()`
  </action>
  <verify>
1. `cd packages/server && pnpm tsc --noEmit` compiles without errors
2. The file exports sessionManager singleton, SessionRoom, ConnectedClient types
  </verify>
  <done>
SessionManager tracks campaign rooms with connected clients, supports filtered broadcasts (all, DM-only, player-only, specific players), manages session status and broadcast modes, and handles staged changes. Exported as singleton for use by handler and message-handlers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create message handlers and wire into WS handler with event logging</name>
  <files>
    packages/server/src/ws/message-handlers.ts
    packages/server/src/ws/handler.ts
  </files>
  <action>
1. Create `packages/server/src/ws/message-handlers.ts`:

   - Import: `sessionManager` from session-manager, `db` from db, `gameSession`, `sessionEvent` from db/schema, `ClientMessageSchema` from shared package, `WSContext` from hono/ws
   - Use crypto.randomUUID() for generating IDs (import from Node crypto)

   - **Helper: `logSessionEvent(sessionId, eventType, userId, payload)`** -- inserts into session_event table via db.insert(sessionEvent).values({ id: crypto.randomUUID(), sessionId, eventType, userId, payload, createdAt: new Date() })

   - **Export: `handleClientMessage(campaignId: string, userId: string, role: 'dm' | 'player', rawData: string | ArrayBuffer, ws: WSContext)`:**
     a. Parse rawData as JSON. If invalid JSON, send error message back via ws.send and return.
     b. Validate with ClientMessageSchema.safeParse(). If invalid, send error message back and return.
     c. Switch on message.type:

     **DM-only actions (check role === 'dm', else send error):**

     - `session:start`:
       - Create a new game_session row in DB: `db.insert(gameSession).values({ id: crypto.randomUUID(), campaignId, startedBy: userId, status: 'active' })`
       - Call `sessionManager.setSessionStatus(campaignId, 'active', sessionId)`
       - Log event: logSessionEvent(sessionId, 'session_start', userId, null)
       - Broadcast `session:statusChanged` with status 'active' to all clients

     - `session:pause`:
       - Update game_session status to 'paused' (via db.update)
       - Call sessionManager.setSessionStatus(campaignId, 'paused')
       - Log event
       - Broadcast `session:statusChanged` with status 'paused'

     - `session:resume`:
       - Update game_session status to 'active'
       - Call sessionManager.setSessionStatus(campaignId, 'active')
       - Log event
       - Broadcast `session:statusChanged` with status 'active'

     - `session:end`:
       - Update game_session: status 'ended', endedAt: new Date()
       - Call sessionManager.setSessionStatus(campaignId, 'ended')
       - Log event
       - Broadcast `session:statusChanged` with status 'ended'

     - `broadcast:mode`:
       - Call sessionManager.setBroadcastMode(campaignId, message.mode)
       - If switching to 'staged', broadcast `dm:preparing` with preparing: true to players
       - If switching to 'immediate', broadcast `dm:preparing` with preparing: false to players
       - Send current staged changes to DM if mode is 'staged'

     - `broadcast:publish`:
       - Get staged changes via sessionManager.clearStagedChanges(campaignId)
       - For each staged change, execute the actual action (hex:reveal, hex:update, etc.) and broadcast to appropriate clients
       - Send `dm:preparing` with preparing: false to players
       - Switch broadcast mode back to 'immediate' after publish

     - `staged:undo`:
       - Call sessionManager.undoStagedChange(campaignId, message.index)
       - Send updated staged:changes list to DM

     - `hex:reveal`:
       - If broadcast mode is 'staged': add to staged changes, send updated list to DM
       - If broadcast mode is 'immediate': broadcast `hex:revealed` to target players (all or specific playerIds)
       - Log event with hex keys and targets in payload

     - `hex:update`:
       - If broadcast mode is 'staged': add to staged changes, send updated list to DM
       - If broadcast mode is 'immediate': broadcast `hex:updated` to all clients
       - Log event

2. Update `packages/server/src/ws/handler.ts`:
   - Import `sessionManager` from `./session-manager.js`
   - Import `handleClientMessage` from `./message-handlers.js`
   - In the onOpen handler:
     - Call `sessionManager.addConnection(campaignId, userId, session.user.name, role, ws)`
     - Log event: insert player_join into session_event IF there's an active session (check room.sessionId)
   - In the onMessage handler:
     - Call `handleClientMessage(campaignId, userId, role, event.data.toString(), ws)`
   - In the onClose handler:
     - Call `sessionManager.removeConnection(campaignId, userId)`
     - Log player_leave event if active session
  </action>
  <verify>
1. `cd packages/server && pnpm tsc --noEmit` compiles without errors
2. Start server, connect as authenticated DM via browser, send `{"type":"session:start"}` -- verify game_session row created in database
3. Send `{"type":"session:pause"}` -- verify status changes and all connected clients receive statusChanged message
  </verify>
  <done>
All client-to-server WebSocket message types are handled. DM session lifecycle (start/pause/resume/end) creates and updates game_session rows and broadcasts status changes. Broadcast mode toggling between immediate and staged works correctly. All session events are logged to session_event table. Non-DM users are rejected from DM-only actions.
  </done>
</task>

</tasks>

<verification>
1. Server compiles and starts: `cd packages/server && pnpm tsc --noEmit && pnpm dev`
2. SessionManager singleton is importable and functional
3. Message handlers process all ClientMessage types without errors
4. DM session lifecycle produces correct database rows in game_session and session_event
5. Role-based filtering prevents players from executing DM actions
</verification>

<success_criteria>
- SessionManager tracks rooms with connection add/remove, filtered broadcast, session status, broadcast modes, and staged changes
- All 9 client message types are handled with appropriate responses and broadcasts
- Session events are persisted to PostgreSQL session_event table
- DM-only actions reject non-DM users with error messages
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-infrastructure/03-02-SUMMARY.md`
</output>
