---
phase: 03-real-time-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/package.json
  - packages/server/src/ws/setup.ts
  - packages/server/src/ws/handler.ts
  - packages/server/src/index.ts
  - packages/server/src/app.ts
  - packages/server/src/db/schema/session.ts
  - packages/server/src/db/schema/index.ts
  - packages/shared/src/ws-messages.ts
  - packages/shared/src/session-types.ts
  - packages/shared/src/index.ts
  - packages/client/vite.config.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket endpoint at /ws accepts upgrade requests with cookie-based authentication"
    - "Unauthenticated WebSocket connections are rejected with close code 4001"
    - "game_session and session_event tables exist in PostgreSQL after migration"
    - "Shared Zod schemas validate all WebSocket message types at runtime"
    - "Vite dev proxy forwards /ws path to backend with ws:true"
  artifacts:
    - path: "packages/server/src/ws/setup.ts"
      provides: "createNodeWebSocket initialization, exports upgradeWebSocket and injectWebSocket"
      exports: ["setupWebSocket"]
    - path: "packages/server/src/ws/handler.ts"
      provides: "WebSocket upgrade route handler with cookie auth and campaignId extraction"
      exports: ["createWsRoute"]
    - path: "packages/server/src/db/schema/session.ts"
      provides: "gameSession and sessionEvent Drizzle tables with enums"
      exports: ["gameSession", "sessionEvent", "sessionStatusEnum", "sessionEventTypeEnum"]
    - path: "packages/shared/src/ws-messages.ts"
      provides: "Zod schemas for server-to-client and client-to-server WS messages"
      exports: ["ServerMessageSchema", "ClientMessageSchema", "ServerMessage", "ClientMessage"]
    - path: "packages/shared/src/session-types.ts"
      provides: "Session status, connection status, and broadcast mode type definitions"
      exports: ["SessionStatus", "ConnectionStatus", "BroadcastMode"]
  key_links:
    - from: "packages/server/src/index.ts"
      to: "packages/server/src/ws/setup.ts"
      via: "setupWebSocket(app) call and injectWebSocket(server)"
      pattern: "setupWebSocket|injectWebSocket"
    - from: "packages/server/src/ws/handler.ts"
      to: "packages/server/src/auth.ts"
      via: "auth.api.getSession({ headers }) inside upgradeWebSocket callback"
      pattern: "auth\\.api\\.getSession"
    - from: "packages/client/vite.config.ts"
      to: "WebSocket server"
      via: "Vite proxy /ws entry with ws: true"
      pattern: "ws:\\s*true"
---

<objective>
Set up the WebSocket server infrastructure, database schema for sessions/events, and shared message type definitions that all subsequent real-time plans depend on.

Purpose: This is the foundation for all real-time communication. Without a working WS endpoint, authenticated connections, session tables, and shared message schemas, no other plan in Phase 3 can function.

Output: A WebSocket endpoint at /ws that authenticates via cookies, database tables for session tracking, Zod-validated message schemas shared between client and server, and Vite proxy configured for WS forwarding.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-infrastructure/03-RESEARCH.md

# Key existing files
@packages/server/src/index.ts
@packages/server/src/app.ts
@packages/server/src/auth.ts
@packages/server/src/db/schema/index.ts
@packages/server/src/db/schema/campaign.ts
@packages/shared/src/index.ts
@packages/client/vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @hono/node-ws, create WS setup and handler, wire into server entry point</name>
  <files>
    packages/server/package.json
    packages/server/src/ws/setup.ts
    packages/server/src/ws/handler.ts
    packages/server/src/index.ts
    packages/server/src/app.ts
  </files>
  <action>
1. Install @hono/node-ws in the server package:
   ```bash
   cd packages/server && pnpm add @hono/node-ws
   ```

2. Create `packages/server/src/ws/setup.ts`:
   - Import `createNodeWebSocket` from `@hono/node-ws`
   - Export a `setupWebSocket(app)` function that calls `createNodeWebSocket({ app })` and returns `{ injectWebSocket, upgradeWebSocket }`
   - The app parameter type should be the Hono app type from app.ts

3. Create `packages/server/src/ws/handler.ts`:
   - Export a `createWsRoute(app, upgradeWebSocket)` function that registers `app.get('/ws', ...)` using the `upgradeWebSocket` helper
   - Inside the upgradeWebSocket callback:
     a. Validate Origin header against allowed origins: `['http://localhost:5173', 'http://10.241.120.98:5173']`. If origin is present and not allowed, return handlers that close with code 4003 "Forbidden origin"
     b. Authenticate by calling `auth.api.getSession({ headers: c.req.raw.headers })`. If no session, return handlers that send `{ type: 'error', message: 'Unauthorized' }` and close with code 4001 "Unauthorized"
     c. Extract `campaignId` from URL query params: `new URL(c.req.url).searchParams.get('campaignId')`. If missing, close with 4002 "Missing campaignId"
     d. Look up the user's campaign membership in the database: query `campaignMember` table where `userId` matches and `campaignId` matches. If no membership, close with 4003 "Not a member"
     e. Extract the member's role ('dm' or 'player') from the membership record
     f. Return `{ onOpen, onMessage, onClose }` handlers. For now, onOpen logs connection info and sends a JSON `{ type: 'connected', userId, role }` message. onMessage is a no-op placeholder. onClose logs disconnection.
   - CRITICAL: The WS route must be registered on the app BEFORE any CORS middleware. The existing app.ts scopes CORS to `/api/*` which is fine -- `/ws` won't be affected. But ensure the WS route registration happens correctly. Register the WS route in app.ts BEFORE the CORS middleware line. Import createWsRoute from handler.ts.

4. Modify `packages/server/src/index.ts`:
   - Import `setupWebSocket` from `./ws/setup.js`
   - Call `const { injectWebSocket, upgradeWebSocket } = setupWebSocket(app)` BEFORE `serve()`
   - Pass `upgradeWebSocket` to wherever the WS route is registered (import and call `createWsRoute(app, upgradeWebSocket)`)
   - Capture the return value of `serve()` into a `server` variable
   - Call `injectWebSocket(server)` AFTER serve()
   - The serve callback still logs the port

5. Modify `packages/server/src/app.ts`:
   - Add an `initWsRoute` export function (or accept the WS route registration via a function parameter) that can be called from index.ts to register the `/ws` route before middleware. Since `upgradeWebSocket` is only available after `setupWebSocket(app)` is called in index.ts, the cleanest pattern is:
     - Export a function `registerWsRoute(upgradeWebSocket)` from handler.ts
     - Call it in index.ts after setupWebSocket but before serve
     - The function registers `app.get('/ws', upgradeWebSocket(...))` directly on the imported app
   - Alternatively, just register the route in index.ts directly by importing app and calling `app.get('/ws', ...)` there. Pick the cleanest approach. The key constraint: the WS route must be on the app BEFORE middleware runs, but since CORS is scoped to `/api/*`, `/ws` won't conflict regardless of registration order.

6. Update `packages/client/vite.config.ts`:
   - Add a `/ws` proxy entry:
     ```typescript
     '/ws': {
       target: 'ws://localhost:3000',
       ws: true,
     },
     ```
  </action>
  <verify>
1. `cd packages/server && pnpm tsc --noEmit` compiles without errors
2. Start the server: the console shows "Server running at http://0.0.0.0:3000"
3. Test unauthenticated WS connection: `wscat -c ws://localhost:3000/ws?campaignId=test` receives an error message and is closed with code 4001
4. If wscat is not installed, verify by checking server logs for connection attempt handling
  </verify>
  <done>
Server starts with WebSocket support. /ws endpoint rejects unauthenticated connections with close code 4001. CORS middleware at /api/* does not interfere with WebSocket upgrade. Vite config includes /ws proxy with ws:true.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session/event database schema and shared message type definitions</name>
  <files>
    packages/server/src/db/schema/session.ts
    packages/server/src/db/schema/index.ts
    packages/shared/src/ws-messages.ts
    packages/shared/src/session-types.ts
    packages/shared/src/index.ts
  </files>
  <action>
1. Create `packages/server/src/db/schema/session.ts`:
   - Import pgTable, pgEnum, text, timestamp, jsonb, index from "drizzle-orm/pg-core"
   - Import campaign from "./campaign" and user from "./auth" (extensionless imports per project convention)
   - Define `sessionStatusEnum` as pgEnum("session_status", ["active", "paused", "ended"])
   - Define `gameSession` table:
     - id: text("id").primaryKey() -- use crypto.randomUUID() at insert time (same pattern as campaign table)
     - campaignId: text("campaign_id").notNull().references(() => campaign.id, { onDelete: "cascade" })
     - startedBy: text("started_by").notNull().references(() => user.id)
     - status: sessionStatusEnum("status").notNull().default("active")
     - startedAt: timestamp("started_at").defaultNow().notNull()
     - endedAt: timestamp("ended_at")
   - Define `sessionEventTypeEnum` as pgEnum("session_event_type", ["session_start", "session_pause", "session_resume", "session_end", "hex_reveal", "hex_update", "player_join", "player_leave", "token_move"])
   - Define `sessionEvent` table:
     - id: text("id").primaryKey()
     - sessionId: text("session_id").notNull().references(() => gameSession.id, { onDelete: "cascade" })
     - eventType: sessionEventTypeEnum("event_type").notNull()
     - userId: text("user_id").references(() => user.id)
     - payload: jsonb("payload").$type<Record<string, unknown>>()
     - createdAt: timestamp("created_at").defaultNow().notNull()
   - Add indexes: on sessionEvent.sessionId and sessionEvent.createdAt

2. Update `packages/server/src/db/schema/index.ts`:
   - Add `export * from "./session"` line

3. Run database migration:
   ```bash
   cd packages/server && pnpm drizzle-kit push
   ```

4. Create `packages/shared/src/session-types.ts`:
   - Export type `SessionStatus = 'waiting' | 'active' | 'paused' | 'ended'`
   - Export type `ConnectionStatus = 'disconnected' | 'connecting' | 'connected' | 'reconnecting'`
   - Export type `BroadcastMode = 'immediate' | 'staged'`
   - Export type `PlayerPresence = { userId: string; name: string; online: boolean }`
   - Export type `StagedChange = { id: string; description: string; type: string; data: unknown }`

5. Create `packages/shared/src/ws-messages.ts`:
   - Import z from 'zod' (zod is already installed in the shared package -- verify, if not install it)
   - Define `ServerMessageSchema` as z.discriminatedUnion('type', [...]) with these message types:
     - `session:state` -- full state sync (status, broadcastMode, connectedPlayers array, revealedHexes array)
     - `session:statusChanged` -- status enum change
     - `hex:revealed` -- hexKeys array with terrain data
     - `hex:updated` -- changes array
     - `player:joined` -- userId, name
     - `player:left` -- userId
     - `player:presence` -- full presence list update
     - `dm:preparing` -- boolean flag for staged mode indicator
     - `staged:changes` -- array of staged changes (for DM only)
     - `error` -- error message string
     - `connected` -- confirmation with userId and role
   - Define `ClientMessageSchema` as z.discriminatedUnion('type', [...]):
     - `session:start`
     - `session:pause`
     - `session:resume`
     - `session:end`
     - `broadcast:mode` -- with mode field
     - `broadcast:publish` -- publish staged changes
     - `hex:reveal` -- hexKeys array + targets (all | { playerIds: string[] })
     - `hex:update` -- changes array
     - `staged:undo` -- index number
   - Export inferred types: `ServerMessage`, `ClientMessage`

6. Update `packages/shared/src/index.ts`:
   - Re-export from ws-messages.ts and session-types.ts
   - Export schemas, types, and all type aliases

7. Verify shared package compiles: `cd packages/shared && pnpm tsc --noEmit` (or equivalent build check)
  </action>
  <verify>
1. `cd packages/server && pnpm drizzle-kit push` succeeds, creating game_session and session_event tables
2. `psql` or drizzle-kit studio shows the new tables with correct columns
3. `cd packages/shared && pnpm tsc --noEmit` compiles without errors
4. `cd packages/server && pnpm tsc --noEmit` compiles without errors (imports from shared work)
  </verify>
  <done>
Database has game_session and session_event tables with proper FK relationships and indexes. Shared package exports Zod schemas (ServerMessageSchema, ClientMessageSchema) and TypeScript types (SessionStatus, ConnectionStatus, BroadcastMode, PlayerPresence, StagedChange) that both server and client can import.
  </done>
</task>

</tasks>

<verification>
1. Server starts without errors: `cd packages/server && pnpm dev`
2. WebSocket endpoint rejects unauthenticated connections
3. Database migration creates session tables: `SELECT * FROM game_session LIMIT 0` succeeds
4. Shared message schemas are importable from both server and client packages
5. Vite dev server proxies /ws to backend
</verification>

<success_criteria>
- WebSocket server endpoint at /ws authenticates via cookies and rejects unauthorized connections
- game_session and session_event PostgreSQL tables exist with proper constraints
- Shared Zod message schemas validate all WS message types
- Vite proxy forwards /ws with WebSocket support
- All packages compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-infrastructure/03-01-SUMMARY.md`
</output>
