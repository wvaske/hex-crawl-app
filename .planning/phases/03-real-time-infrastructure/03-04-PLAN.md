---
phase: 03-real-time-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - packages/client/src/App.tsx
  - packages/client/src/components/campaigns/CampaignDashboard.tsx
  - packages/client/src/components/campaigns/SessionControls.tsx
  - packages/client/src/components/campaigns/PlayerPresenceList.tsx
autonomous: false

must_haves:
  truths:
    - "DM can start a session from the campaign dashboard and all connected players receive the status change"
    - "DM can pause, resume, and end a session with all clients updated in real time"
    - "DM sees a player presence list showing who is online/offline"
    - "DM can toggle between immediate and staged broadcast modes"
    - "Players see 'Waiting for DM' overlay when entering a campaign without an active session"
    - "Players see session status changes (pause/resume/end) without refreshing"
    - "A client that disconnects and reconnects receives the current session state"
    - "Connection lost banner appears on disconnect and disappears on reconnect"
  artifacts:
    - path: "packages/client/src/components/campaigns/SessionControls.tsx"
      provides: "DM session lifecycle controls: start, pause, resume, end, broadcast mode toggle"
      exports: ["SessionControls"]
    - path: "packages/client/src/components/campaigns/PlayerPresenceList.tsx"
      provides: "Online/offline player list in campaign dashboard sidebar"
      exports: ["PlayerPresenceList"]
  key_links:
    - from: "packages/client/src/App.tsx"
      to: "packages/client/src/hooks/useWebSocket.ts"
      via: "useWebSocket(campaignId) called when viewing campaign"
      pattern: "useWebSocket"
    - from: "packages/client/src/App.tsx"
      to: "packages/client/src/components/ConnectionBanner.tsx"
      via: "ConnectionBanner rendered at top level"
      pattern: "<ConnectionBanner"
    - from: "packages/client/src/components/campaigns/SessionControls.tsx"
      to: "packages/client/src/stores/useSessionStore.ts"
      via: "sendMessage dispatches DM session commands"
      pattern: "sendMessage.*session:(start|pause|resume|end)"
    - from: "packages/client/src/components/campaigns/CampaignDashboard.tsx"
      to: "packages/client/src/components/campaigns/SessionControls.tsx"
      via: "SessionControls rendered inside dashboard"
      pattern: "<SessionControls"
---

<objective>
Wire all real-time components together: integrate WebSocket connection into the app lifecycle, add DM session controls and player presence to the campaign dashboard, render connection and session overlays, and verify the complete real-time flow end-to-end.

Purpose: Plans 01-03 built independent pieces (server WS, session manager, client store/hook, UI components). This plan connects them into a working system where a DM can start a session and connected players see it happen live. This is the integration and verification plan that proves Phase 3's success criteria.

Output: A fully integrated real-time system where DM session controls in the dashboard trigger live updates for all connected clients, with connection feedback and session overlays working correctly.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-infrastructure/03-RESEARCH.md
@.planning/phases/03-real-time-infrastructure/03-01-SUMMARY.md
@.planning/phases/03-real-time-infrastructure/03-02-SUMMARY.md
@.planning/phases/03-real-time-infrastructure/03-03-SUMMARY.md

# Key existing files
@packages/client/src/App.tsx
@packages/client/src/components/campaigns/CampaignDashboard.tsx
@packages/client/src/hooks/useWebSocket.ts
@packages/client/src/stores/useSessionStore.ts
@packages/client/src/components/ConnectionBanner.tsx
@packages/client/src/components/SessionOverlay.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DM session controls and player presence components</name>
  <files>
    packages/client/src/components/campaigns/SessionControls.tsx
    packages/client/src/components/campaigns/PlayerPresenceList.tsx
  </files>
  <action>
1. Create `packages/client/src/components/campaigns/SessionControls.tsx`:
   - Import useSessionStore
   - Read: sessionStatus, broadcastMode, sendMessage, userRole from store

   **DM Session Controls UI (only rendered when userRole === 'dm'):**

   **Session lifecycle buttons (rendered based on sessionStatus):**
   - `waiting` state: Show "Start Session" button (green). Sends `{ type: 'session:start' }`
   - `active` state: Show "Pause Session" button (yellow) and "End Session" button (red). Pause sends `{ type: 'session:pause' }`, End sends `{ type: 'session:end' }` with confirm dialog first.
   - `paused` state: Show "Resume Session" button (green) and "End Session" button (red). Resume sends `{ type: 'session:resume' }`.
   - `ended` state: Show "Start New Session" button (green). Same as start.

   **Broadcast mode toggle (only when session is active):**
   - Toggle switch or button group: "Immediate" | "Staged"
   - Current mode highlighted
   - Clicking sends `{ type: 'broadcast:mode', mode: 'immediate' | 'staged' }`

   **Staged changes panel (only when broadcastMode is 'staged'):**
   - Read stagedChanges from store
   - Show list of pending changes with description
   - Each change has an "Undo" button that sends `{ type: 'staged:undo', index: N }`
   - "Publish All" button at bottom sends `{ type: 'broadcast:publish' }`
   - Show count badge: "N pending changes"

   **Styling (Tailwind dark theme):**
   - Card container: `bg-gray-800 border border-gray-700 rounded-lg p-4`
   - Section header: `text-gray-200 font-semibold text-sm mb-2`
   - Buttons: use consistent button styles from the codebase (see CampaignDashboard for reference)
   - Start/Resume: `bg-green-600 hover:bg-green-500 text-white`
   - Pause: `bg-yellow-600 hover:bg-yellow-500 text-white`
   - End: `bg-red-600 hover:bg-red-500 text-white`
   - Staged changes list: `bg-gray-900 rounded p-2` with items as `text-gray-300 text-sm`

2. Create `packages/client/src/components/campaigns/PlayerPresenceList.tsx`:
   - Import useSessionStore
   - Read connectedPlayers from store

   **Player presence list:**
   - Header: "Players" with online count badge
   - List each player: name with online/offline status indicator
   - Online: green dot `bg-green-500 rounded-full w-2 h-2 inline-block`
   - Offline: gray dot `bg-gray-500 rounded-full w-2 h-2 inline-block`
   - If no players connected: "No players connected" in gray text

   **Styling:**
   - Card container: `bg-gray-800 border border-gray-700 rounded-lg p-4`
   - Player name: `text-gray-200 text-sm`
   - Status dots inline with player names
  </action>
  <verify>
1. `cd packages/client && pnpm tsc --noEmit` compiles without errors
2. SessionControls renders appropriate buttons based on session status
3. PlayerPresenceList renders connected players from store
  </verify>
  <done>
SessionControls provides DM with start/pause/resume/end session buttons, broadcast mode toggle, and staged changes panel with undo/publish. PlayerPresenceList shows online/offline players with status indicators. Both components read from useSessionStore and send messages via sendMessage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire WebSocket, overlays, and session controls into App and CampaignDashboard</name>
  <files>
    packages/client/src/App.tsx
    packages/client/src/components/campaigns/CampaignDashboard.tsx
  </files>
  <action>
1. Modify `packages/client/src/App.tsx`:
   - Import `useWebSocket` from hooks/useWebSocket
   - Import `ConnectionBanner` from components/ConnectionBanner
   - Import `SessionOverlay` from components/SessionOverlay

   **In AppContent component:**
   - Call `useWebSocket(selectedCampaignId)` -- this connects when a campaign is selected (dashboard or map view), disconnects when deselected
   - The hook handles its own cleanup when campaignId changes to null (going back to campaign list)
   - Render `<ConnectionBanner />` at the top of the component JSX (inside the relative div, as first child) -- this is a fixed-position element so it won't affect layout
   - Render `<SessionOverlay />` after ConnectionBanner -- also fixed-position

   **Integration notes:**
   - The WebSocket connects as soon as a campaign is selected (entering dashboard view) and stays connected through map view
   - When navigating back to campaign list (selectedCampaignId becomes null), the hook disconnects and resets the session store
   - This means session state persists across dashboard -> map -> dashboard navigation within the same campaign

2. Modify `packages/client/src/components/campaigns/CampaignDashboard.tsx`:
   - Import `SessionControls` from `./SessionControls`
   - Import `PlayerPresenceList` from `./PlayerPresenceList`
   - Import `useSessionStore` to read userRole

   **Add to the dashboard layout:**
   - In the sidebar area (or below existing campaign info), add:
     - `<SessionControls />` -- visible to DM only (the component handles role check internally, but you can also conditionally render)
     - `<PlayerPresenceList />` -- visible to DM only
   - For players in the dashboard: show session status text (e.g., "Session: Active", "Session: Waiting for DM")
   - Read sessionStatus from store and display it

   **Layout adjustment:**
   - The existing CampaignDashboard likely has a main content area. Add the session controls and presence list in a sidebar or below the existing content.
   - Use a two-column layout if not already present: main content (campaign info, invite controls, enter map button) on the left, session sidebar (controls + presence) on the right
   - If the component is simple enough, just stack them vertically: campaign info -> session controls -> presence list -> action buttons

   **Player view of dashboard:**
   - Show session status badge: "Active" (green), "Waiting" (yellow), "Paused" (orange), "Ended" (gray)
   - Show "Enter Map" button (existing) -- works regardless of session status (outside sessions = read-only map access per context)
  </action>
  <verify>
1. `cd packages/client && pnpm tsc --noEmit` compiles without errors
2. `cd packages/server && pnpm dev` starts the server
3. `cd packages/client && pnpm dev` starts the client
4. Navigate to a campaign dashboard -- verify WebSocket connection is established (check browser DevTools Network tab for /ws connection)
5. As DM, click "Start Session" -- verify game_session row created in database and session status updates in UI
  </verify>
  <done>
App.tsx connects WebSocket when a campaign is selected and renders ConnectionBanner + SessionOverlay at the top level. CampaignDashboard shows DM session controls and player presence list. The complete real-time flow works: DM starts session -> server creates game_session -> broadcasts status -> all clients update.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete real-time infrastructure: WebSocket server with cookie auth, session manager, message handlers, client WebSocket hook with reconnection, session store, connection banner, session overlays, DM session controls, and player presence list.
  </what-built>
  <how-to-verify>
**Test with two browser windows (or two browser profiles for different users):**

1. **Setup:** Start server (`cd packages/server && pnpm dev`) and client (`cd packages/client && pnpm dev`). Have two user accounts -- one DM, one player -- both members of the same campaign.

2. **Connection test:**
   - Log in as DM in Browser 1, navigate to the campaign dashboard
   - Check DevTools Network tab: a WebSocket connection to `/ws?campaignId=...` should be open
   - Log in as Player in Browser 2, navigate to the same campaign dashboard
   - Player should see "Waiting for DM to start the session..." overlay

3. **Session lifecycle test:**
   - As DM (Browser 1), click "Start Session"
   - Player (Browser 2) should see the waiting overlay disappear immediately (no refresh needed)
   - DM clicks "Pause Session" -> Player sees grey "Session Paused" overlay
   - DM clicks "Resume Session" -> Player overlay disappears
   - DM clicks "End Session" -> Player sees "Session ended" banner

4. **Reconnection test:**
   - With session active, stop the server (Ctrl+C)
   - Both browsers should show "Connection lost. Reconnecting..." banner
   - Restart the server
   - Banners should disappear automatically within a few seconds
   - Session state should be restored (DM sees controls, player sees correct status)

5. **Presence test:**
   - DM dashboard should show the player in the presence list with a green dot
   - Close the player's browser tab -> DM presence list should update (player goes offline)

6. **Database verification:**
   - Check PostgreSQL: `SELECT * FROM game_session` should show session records
   - `SELECT * FROM session_event ORDER BY created_at` should show session_start, session_pause, session_resume, session_end events with timestamps
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues observed</resume-signal>
</task>

</tasks>

<verification>
1. Full TypeScript compilation: both server and client compile without errors
2. WebSocket connects from browser to server with cookie-based auth
3. DM session lifecycle (start/pause/resume/end) works with real-time updates to all clients
4. Connection loss shows banner, reconnection dismisses it
5. Player presence list updates when players connect/disconnect
6. Session events are logged in PostgreSQL
7. Players see appropriate overlays based on session state
</verification>

<success_criteria>
- DM starts session from dashboard -> all players see it immediately (RT-01: map changes propagate in real time)
- DM client receives full session state (RT-02)
- Player client receives only role-appropriate state (RT-03: no DM-only staged changes visible)
- Disconnected client reconnects and receives current state (RT-05)
- Session events persisted in PostgreSQL for future replay
- All Phase 3 success criteria from ROADMAP.md are met
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-infrastructure/03-04-SUMMARY.md`
</output>
