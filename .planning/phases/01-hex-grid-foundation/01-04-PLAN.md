---
phase: 01-hex-grid-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - packages/client/src/canvas/layers/HighlightLayer.tsx
  - packages/client/src/canvas/layers/UIOverlayLayer.tsx
  - packages/client/src/canvas/HexInteraction.tsx
  - packages/client/src/components/MapView.tsx
  - packages/client/src/components/ImportExportDialog.tsx
  - packages/client/src/App.tsx
  - packages/client/src/hex/import-export.ts
autonomous: false

must_haves:
  truths:
    - "Hovering a hex shows its axial coordinates (q, r) and a visible highlight"
    - "Clicking a hex selects it and shows info in the side panel"
    - "Shift-clicking adds/removes hexes from multi-selection"
    - "User can export the map as JSON and re-import it with terrain preserved"
    - "Terrain palette assigns terrain to selected hexes and the canvas updates immediately"
    - "Full end-to-end flow works: create map, see terrain, pan/zoom, select hex, view info, change terrain, export/import"
  artifacts:
    - path: "packages/client/src/canvas/layers/HighlightLayer.tsx"
      provides: "Hover and selection highlight overlays on hexes"
      exports: ["HighlightLayer"]
      min_lines: 40
    - path: "packages/client/src/canvas/layers/UIOverlayLayer.tsx"
      provides: "Coordinate text display on hover"
      exports: ["UIOverlayLayer"]
      min_lines: 20
    - path: "packages/client/src/canvas/HexInteraction.tsx"
      provides: "Mouse event handling for hex hover, click, shift-click, drag-select"
      exports: ["HexInteraction"]
      min_lines: 60
    - path: "packages/client/src/hex/import-export.ts"
      provides: "JSON export and import with Zod validation"
      exports: ["exportMap", "importMap"]
      min_lines: 40
    - path: "packages/client/src/components/ImportExportDialog.tsx"
      provides: "UI for JSON file download and upload"
      exports: ["ImportExportDialog"]
      min_lines: 50
  key_links:
    - from: "packages/client/src/canvas/HexInteraction.tsx"
      to: "packages/client/src/stores/useUIStore.ts"
      via: "updates hoveredHex, selectedHexes on mouse events"
      pattern: "useUIStore"
    - from: "packages/client/src/canvas/HexInteraction.tsx"
      to: "packages/client/src/hex/coordinates.ts"
      via: "pixelToHex for mouse position to hex lookup"
      pattern: "pixelToHex"
    - from: "packages/client/src/canvas/layers/HighlightLayer.tsx"
      to: "packages/client/src/stores/useUIStore.ts"
      via: "reads hoveredHex and selectedHexes for highlight rendering"
      pattern: "useUIStore"
    - from: "packages/client/src/hex/import-export.ts"
      to: "packages/shared/src/map-schema.ts"
      via: "validates import data with MapExportSchema"
      pattern: "MapExportSchema"
    - from: "packages/client/src/components/ImportExportDialog.tsx"
      to: "packages/client/src/hex/import-export.ts"
      via: "calls exportMap and importMap"
      pattern: "exportMap|importMap"
---

<objective>
Wire interaction (hover, click, shift-click multi-select, drag-select), highlight rendering, coordinate display, JSON import/export, and integrate all systems into the final MapView layout. This plan connects the canvas (Plan 02) with the React UI (Plan 03) through Zustand stores and adds the remaining interactive features.

Purpose: This completes Phase 1 by adding all user interaction and connecting every component. After this plan, the full end-to-end flow works: create a map, see clustered terrain, pan/zoom, hover to see coordinates, click to select, shift-click to multi-select, assign terrain, export to JSON, and import from JSON.
Output: Complete interactive hex grid application with all Phase 1 features functional.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-hex-grid-foundation/01-CONTEXT.md
@.planning/phases/01-hex-grid-foundation/01-RESEARCH.md
@.planning/phases/01-hex-grid-foundation/01-01-SUMMARY.md
@.planning/phases/01-hex-grid-foundation/01-02-SUMMARY.md
@.planning/phases/01-hex-grid-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement hex interaction (hover, click, multi-select) and highlight/overlay layers</name>
  <files>
    packages/client/src/canvas/HexInteraction.tsx
    packages/client/src/canvas/layers/HighlightLayer.tsx
    packages/client/src/canvas/layers/UIOverlayLayer.tsx
  </files>
  <action>
    **packages/client/src/canvas/HexInteraction.tsx -- Mouse event handling:**

    This component manages all mouse interaction with the hex canvas. It attaches event listeners to the pixi-viewport and translates mouse positions to hex coordinates.

    1. **Hover detection:**
       - Listen to viewport `pointermove` events
       - Convert mouse world position to hex coordinates using `pixelToHex(worldX, worldY, hexPrototype)`
       - If the hex coordinate changed from last frame, call `useUIStore.getState().setHoveredHex(hexKey)` (or null if off-grid)
       - Throttle hover updates to avoid excessive store updates (use requestAnimationFrame or limit to ~30 updates/sec)

    2. **Click selection:**
       - Listen to viewport `pointerdown` + `pointerup` (or `click`) events -- but ONLY register as a click if the pointer didn't move significantly (to distinguish click from drag)
       - On click (no shift): call `useUIStore.getState().selectHex(hexKey)` -- clears previous selection, selects this hex
       - On shift-click: call `useUIStore.getState().toggleSelectHex(hexKey)` -- adds/removes from multi-selection
       - On click on empty space (no hex): call `useUIStore.getState().clearSelection()`

    3. **Drag-select (area selection):**
       - On pointer down + drag (with some modifier like left-click drag without hitting the viewport drag): detect rectangular area
       - NOTE: This conflicts with viewport drag-to-pan. Resolution: viewport drag is the primary behavior. Drag-select could use a modifier key (e.g., hold Alt or Ctrl while dragging). OR implement it as shift+drag. Choose the approach that feels most natural.
       - Recommended: Shift+drag for area select (shift is already the multi-select modifier). When shift is held, disable viewport drag and instead track a selection rectangle. On release, find all hexes within the rectangle and add them to selection.
       - Convert rectangle corners to hex coordinates, find all hexes in that range, add to selectedHexes

    4. Implementation approach: This should be a non-visual component (or hook) that lives inside the @pixi/react tree (so it has access to the viewport). Use `useApplication()` and access the viewport via ref. Attach event listeners in useEffect.

    IMPORTANT: Distinguish click from drag. A click is pointer down + pointer up with minimal movement (<5px). A drag is pointer down + move + pointer up. If you interpret drags as clicks, the user will select hexes every time they pan.
    IMPORTANT: Convert screen coordinates to world coordinates before hex lookup. The viewport transforms screen space to world space. Use `viewport.toWorld(screenX, screenY)` or equivalent.

    **packages/client/src/canvas/layers/HighlightLayer.tsx -- Visual highlights:**

    1. Read `hoveredHex` and `selectedHexes` from `useUIStore`
    2. For the hovered hex:
       - Draw a semi-transparent yellow overlay (0xffff00, alpha 0.3) covering the hex shape
       - Draw a thick yellow border (3px, alpha 0.8) around the hex
       - Use Graphics with hex corner coordinates from honeycomb-grid
       - Use GraphicsContext sharing if multiple highlights use the same shape (RESEARCH.md example)
    3. For selected hexes:
       - Draw a semi-transparent cyan overlay (0x00ffff, alpha 0.2) on each selected hex
       - Draw a cyan border (2px, alpha 0.6)
    4. This layer sits at z-index 2 (above terrain and grid lines)
    5. Highlights update reactively when Zustand store changes

    IMPORTANT: Use Graphics for highlights (not Sprites) -- these are dynamic overlays that change frequently. Graphics is appropriate for a small number of dynamic shapes (1 hover + N selected). Only hex TILES use Sprites.

    **packages/client/src/canvas/layers/UIOverlayLayer.tsx -- Coordinate display:**

    1. Read `hoveredHex` from `useUIStore`
    2. When a hex is hovered, show its axial coordinates as text near the hex:
       - Display "q: {q}, r: {r}" using PixiJS Text or BitmapText
       - Position the text at the hex center (or slightly above)
       - White text with dark semi-transparent background for readability
       - Small font size (12-14px)
    3. Only show coordinates on hover (CONTEXT.md decision: "Coordinates shown on hover only")
    4. This layer sits at z-index 3 (topmost)

    Note: Coordinate display is lightweight (1 text element). PixiJS Text is fine here.
  </action>
  <verify>
    1. Hover over hexes: yellow highlight appears on the hovered hex
    2. Hover over hexes: coordinates (q, r) appear as text overlay
    3. Click a hex: cyan selection highlight appears, side panel shows hex info
    4. Shift-click another hex: both hexes highlighted, side panel shows multi-select info
    5. Click empty space: selection cleared
    6. Pan by dragging: no accidental hex selection during pan
    7. Shift+drag: area selection works (multiple hexes selected)
    8. Performance: hover highlight updates smoothly at ~30+ FPS during mouse movement
  </verify>
  <done>
    Hex interaction fully functional: hover shows yellow highlight + coordinate tooltip, click selects with cyan highlight, shift-click multi-selects, shift-drag area-selects. Click vs drag distinguished correctly (no accidental selections during pan). All interaction state flows through Zustand stores.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build JSON import/export and integrate full MapView layout</name>
  <files>
    packages/client/src/hex/import-export.ts
    packages/client/src/components/ImportExportDialog.tsx
    packages/client/src/components/MapView.tsx
    packages/client/src/App.tsx
  </files>
  <action>
    **packages/client/src/hex/import-export.ts -- JSON serialization:**

    1. `exportMap(store: MapStoreState): string`:
       - Read map name, gridWidth, gridHeight, hexSize from store
       - Convert hexes Map to array of { q, r, terrain, terrainVariant } objects
       - Build MapExport object with version: 1, orientation: 'flat'
       - Return `JSON.stringify(mapExport, null, 2)` for human-readable output

    2. `importMap(jsonString: string): { name, gridWidth, gridHeight, hexSize, hexes: Map<string, HexData> }`:
       - Parse JSON string
       - Validate with `MapExportSchema.parse(data)` from @hex-crawl/shared (Zod validation)
       - Convert hexes array back to Map<string, HexData>
       - Return structured data ready for `useMapStore.getState().initializeMap()`
       - On validation failure, throw descriptive error (what field failed, expected vs actual)

    **packages/client/src/components/ImportExportDialog.tsx -- File I/O UI:**

    1. **Export section:**
       - "Export Map" button
       - On click: call `exportMap(useMapStore.getState())`, create a Blob, trigger browser download as `{mapName}.json`
       - Use `URL.createObjectURL(blob)` + hidden `<a>` element + `.click()` pattern for download

    2. **Import section:**
       - File input accepting `.json` files
       - On file select: read file with FileReader, call `importMap(contents)`
       - On success: call `useMapStore.getState().initializeMap()` with imported data, show success message
       - On failure: show error message with validation details (do not crash)
       - Style: drag-and-drop zone or standard file picker with Tailwind dark theme

    3. Error handling: catch Zod validation errors and display them clearly (field name, expected type, actual value)

    **packages/client/src/components/MapView.tsx -- Final integration:**

    Update MapView to compose everything together:
    1. Layout: `flex h-screen bg-gray-900`
       - Left/main area (flex-1): HexMapCanvas component (from Plan 02)
       - Right side (w-[300px]): SidePanel component (from Plan 03)
    2. Import and render HexMapCanvas (not a placeholder anymore)
    3. Pass through any needed props or context
    4. Handle responsive behavior: side panel should be collapsible

    **packages/client/src/App.tsx -- App root:**

    Update App.tsx to:
    1. Render MapView as the main component
    2. On initial load, show the CreationDialog (useUIStore.showCreationDialog = true)
    3. Once user creates a map via CreationDialog, the canvas shows the generated terrain grid
    4. If no map exists yet, show a centered "Create New Map" button that opens CreationDialog
    5. Wire up the side panel's Import/Export tab to show ImportExportDialog

    This is the final wiring that connects:
    - Creation dialog -> terrain generation -> Zustand store -> canvas rendering
    - Canvas interaction -> Zustand store -> side panel display
    - Terrain palette -> Zustand store -> canvas re-render (terrain sprites update)
    - Export button -> Zustand store -> JSON file download
    - Import file -> Zod validation -> Zustand store -> canvas re-render
  </action>
  <verify>
    1. Full end-to-end flow:
       a. App loads, shows "Create New Map" or CreationDialog
       b. Enter name "Test", width 15, height 15, click Generate
       c. Hex grid appears with clustered terrain
       d. Pan by dragging, zoom by scrolling -- smooth
       e. Hover hex: see coordinates and yellow highlight
       f. Click hex: see cyan selection, side panel shows q,r and terrain type
       g. Shift-click more hexes: multi-select works
       h. Switch to Terrain tab, click "Mountain": selected hexes change to mountain texture
       i. Switch to Import/Export tab, click Export: JSON file downloads
       j. Verify JSON file contains version, name, grid dimensions, hex data array
       k. Refresh page, create new map, switch to Import/Export, import the downloaded file
       l. Map restores with correct terrain assignments
    2. Zod validation: try importing an invalid JSON file -- error message appears, app does not crash
    3. Performance: 60 FPS maintained during pan/zoom with all layers active
    4. TypeScript: `pnpm -r exec -- npx tsc --noEmit` passes
  </verify>
  <done>
    Complete Phase 1 integration: MapView renders canvas + side panel, creation dialog generates maps with clustered terrain, hex interaction (hover/click/multi-select) works, terrain palette changes hex terrain, JSON export produces valid file, JSON import restores map with Zod validation. All Phase 1 success criteria met.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Visual and functional verification of complete hex grid</name>
  <what-built>
    Complete interactive hex grid application with:
    - Flat-top hex grid rendered with terrain texture sprites
    - Pan (drag) and zoom (scroll wheel) navigation
    - Hover highlights with coordinate display
    - Click selection and shift-click multi-selection
    - Side panel with hex info, terrain palette, creation dialog
    - Terrain generation with clustered regions
    - Manual terrain assignment
    - JSON import/export
  </what-built>
  <how-to-verify>
    1. Open http://localhost:5173 (or whatever port Vite serves on)
    2. Verify: Creation dialog appears. Enter "Test Map", 20x20 grid, click Generate.
    3. Verify: Hex grid appears with clustered terrain (water bodies, forest regions, etc. -- not random salt-and-pepper)
    4. Verify: Hexes are flat-top orientation (flat edge at top)
    5. Verify: Pan by click-dragging. Map moves smoothly in all directions.
    6. Verify: Zoom by scrolling mouse wheel. Zoom is smooth (not stepped). Min/max zoom limits apply.
    7. Verify: Hover over a hex. Yellow highlight appears. Coordinates (q, r) display.
    8. Verify: Click a hex. Cyan selection highlight. Side panel shows hex coordinates and terrain type.
    9. Verify: Shift-click 2 more hexes. All 3 selected with cyan highlight. Side panel shows count.
    10. Verify: In side panel, switch to Terrain tab. Click "Desert". All 3 selected hexes change to desert color.
    11. Verify: Switch to Import/Export tab. Click Export. JSON file downloads.
    12. Verify: Open JSON file. Contains version, name, grid dimensions, hex data with q, r, terrain fields.
    13. Verify: Create new map (switch to Create tab, generate). Import the previously exported file. Terrain matches the exported map.
    14. Verify: Performance feels smooth -- no visible jank during pan/zoom with 400 hexes (20x20).
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Phase 1 Success Criteria (from ROADMAP.md):
1. User sees a hex grid rendered on a canvas with configurable hex sizes -- VERIFIED by creation dialog with size option
2. Each hex displays its terrain type visually (distinct colors/styles for forest, desert, grassland, mountain, water, swamp) -- VERIFIED by terrain texture sprites
3. User can pan the map by dragging and zoom with scroll wheel smoothly -- VERIFIED by pixi-viewport
4. Hex grid uses axial/cube coordinate system internally (verified by hovering a hex and seeing its coordinates) -- VERIFIED by coordinate overlay on hover
5. Grid renders at 60 FPS with 500+ hexes visible without jank -- VERIFIED by Performance tab profiling
</verification>

<success_criteria>
- Hover shows yellow highlight + coordinate tooltip (q, r)
- Click selects hex, side panel shows info
- Shift-click multi-selects
- Shift-drag area-selects
- Terrain palette assigns terrain to selected hexes, canvas updates immediately
- JSON export produces valid file with all hex data
- JSON import restores map with Zod validation, invalid files show error
- Full app layout: canvas + side panel with tabs
- All 5 Phase 1 success criteria from ROADMAP.md met
</success_criteria>

<output>
After completion, create `.planning/phases/01-hex-grid-foundation/01-04-SUMMARY.md`
</output>
