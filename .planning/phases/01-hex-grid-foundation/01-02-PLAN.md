---
phase: 01-hex-grid-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/client/src/canvas/HexMapCanvas.tsx
  - packages/client/src/canvas/ViewportContainer.tsx
  - packages/client/src/canvas/layers/TerrainLayer.tsx
  - packages/client/src/canvas/layers/GridLineLayer.tsx
  - packages/client/src/canvas/HexSprite.tsx
  - packages/client/src/hex/textures.ts
  - packages/client/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "A hex grid of flat-top hexes renders on screen with terrain colors"
    - "User can pan the map by dragging and zoom with scroll wheel"
    - "Grid renders at 60 FPS with 500+ hexes visible"
    - "Each hex shows a distinct terrain texture (not solid color, has noise/variation)"
  artifacts:
    - path: "packages/client/src/canvas/HexMapCanvas.tsx"
      provides: "@pixi/react Application wrapper for the hex map"
      exports: ["HexMapCanvas"]
      min_lines: 20
    - path: "packages/client/src/canvas/ViewportContainer.tsx"
      provides: "pixi-viewport wrapper with drag/pinch/wheel/decelerate"
      exports: ["ViewportContainer"]
      min_lines: 30
    - path: "packages/client/src/canvas/layers/TerrainLayer.tsx"
      provides: "Sprite-based hex terrain rendering with viewport culling"
      exports: ["TerrainLayer"]
      min_lines: 40
    - path: "packages/client/src/canvas/layers/GridLineLayer.tsx"
      provides: "Hex border outline rendering"
      exports: ["GridLineLayer"]
      min_lines: 20
    - path: "packages/client/src/hex/textures.ts"
      provides: "Runtime terrain texture generation using offscreen Canvas 2D"
      exports: ["generateTerrainTextures", "getTerrainTexture"]
      min_lines: 50
  key_links:
    - from: "packages/client/src/canvas/ViewportContainer.tsx"
      to: "pixi-viewport"
      via: "Viewport with events={app.renderer.events}"
      pattern: "app\\.renderer\\.events"
    - from: "packages/client/src/canvas/layers/TerrainLayer.tsx"
      to: "packages/client/src/stores/useMapStore.ts"
      via: "reads hex data from Zustand store"
      pattern: "useMapStore"
    - from: "packages/client/src/canvas/layers/TerrainLayer.tsx"
      to: "packages/client/src/hex/textures.ts"
      via: "gets terrain textures for sprites"
      pattern: "getTerrainTexture"
    - from: "packages/client/src/canvas/HexMapCanvas.tsx"
      to: "@pixi/react"
      via: "Application component with extend()"
      pattern: "extend\\("
---

<objective>
Build the PixiJS rendering pipeline: canvas setup with @pixi/react, pixi-viewport for pan/zoom, runtime terrain texture generation, and sprite-based hex rendering with layered containers. The user will see a colored hex grid they can drag to pan and scroll to zoom.

Purpose: This is the visual core of the application. Sprite-based rendering (not Graphics polygons) is critical for 60 FPS performance at 500+ hexes. pixi-viewport handles all camera interaction. The layered container architecture (terrain, grid lines, highlights) provides the z-ordering every future feature depends on.
Output: A functional hex map canvas with terrain sprites, grid lines, pan/zoom navigation, and viewport culling.
</objective>

<execution_context>
@/home/developer/.claude/get-shit-done/workflows/execute-plan.md
@/home/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-hex-grid-foundation/01-RESEARCH.md
@.planning/phases/01-hex-grid-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate terrain textures at runtime and set up PixiJS canvas with pixi-viewport</name>
  <files>
    packages/client/src/hex/textures.ts
    packages/client/src/canvas/HexMapCanvas.tsx
    packages/client/src/canvas/ViewportContainer.tsx
  </files>
  <action>
    **packages/client/src/hex/textures.ts -- Runtime Terrain Texture Generation:**

    Create hex-shaped terrain textures using offscreen Canvas 2D, then convert to PixiJS Textures:

    1. `generateHexTexture(color: string, variant: number, hexWidth: number, hexHeight: number)`:
       - Create an offscreen canvas with dimensions matching hex bounding box
       - Draw a flat-top hexagon path (6 vertices) and clip to it
       - Fill with base terrain color
       - Add subtle noise overlay for visual variety: scatter semi-transparent dots or use a simple pixel manipulation pattern. Each variant uses a different random seed for distinct noise.
       - Return the canvas as a data URL or ImageBitmap

    2. `generateTerrainTextures(renderer: Renderer)`:
       - For each of the 10 terrain types, generate 3 variants (30 textures total)
       - Convert each to a PixiJS Texture using `Texture.from(canvas)` or the Assets system
       - Store in a Map<string, Texture> keyed by `"terrain_variant"` (e.g., "forest_0", "forest_1")
       - Return the texture map

    3. `getTerrainTexture(terrain: TerrainType, variant: number)`: lookup from the generated texture map

    Hex dimensions for flat-top: width = 2 * size (80px for size=40), height = sqrt(3) * size (~69.3px for size=40). The hex polygon vertices for flat-top orientation:
    - (w/2 + w/4, 0), (w, h/2), (w/2 + w/4, h), (w/4, h), (0, h/2), (w/4, 0)
    Actually use the standard flat-top hex vertices centered in the bounding box.

    Use terrain colors from TERRAIN_COLORS in shared/hex-types.ts.

    **packages/client/src/canvas/HexMapCanvas.tsx -- @pixi/react Application:**

    1. Import and call `extend({ Container, Sprite, Graphics, Text })` at module level to register PixiJS components for JSX
    2. Also `extend({ Viewport })` from pixi-viewport to register it as a custom component
    3. Create `<HexMapCanvas>` component that renders `<Application>`:
       - `resizeTo` prop: pass a ref to the parent container div (NOT window -- canvas should not fill the entire browser, leave room for side panel)
       - `background={0x1a1a2e}` (dark blue-gray)
       - `antialias={true}`
    4. Inside Application, render `<HexMapContent>` which uses `useApplication()` to get the app instance
    5. HexMapContent initializes texture generation on mount (call `generateTerrainTextures`)
    6. Render ViewportContainer with layer children

    IMPORTANT: @pixi/react v8 uses `extend()` API -- register components BEFORE using them in JSX. JSX elements use lowercase names: `<pixiContainer>`, `<pixiSprite>`, `<pixiGraphics>` (RESEARCH.md Pattern 6).
    IMPORTANT: Pass `events={app.renderer.events}` to Viewport (PITFALL 3).
    IMPORTANT: PixiJS v8 has async init -- @pixi/react handles this internally via the `<Application>` component (PITFALL 2).

    **packages/client/src/canvas/ViewportContainer.tsx -- pixi-viewport wrapper:**

    1. Create a component that renders `<viewport>` JSX element (registered via extend)
    2. Props: screenWidth, screenHeight from app.screen, worldWidth/worldHeight calculated from grid dimensions
    3. On ref callback, configure viewport behaviors:
       - `.drag()` for pan
       - `.pinch()` for mobile pinch-to-zoom
       - `.wheel()` for scroll wheel zoom (smooth, not discrete steps)
       - `.decelerate()` for inertial scrolling
       - `.clampZoom({ minScale: 0.25, maxScale: 4.0 })` for zoom bounds
    4. Pass `events={app.renderer.events}` (CRITICAL -- without this, no mouse/touch events work)
    5. Render children (the layer containers) inside the viewport

    If `<viewport>` JSX does not work cleanly with @pixi/react (RESEARCH.md Open Question 1), fall back to imperative creation: create Viewport in a useEffect, add to stage via `app.stage.addChild(viewport)`, and manage children imperatively. Prefer the declarative approach first.
  </action>
  <verify>
    1. `pnpm dev` renders the PixiJS canvas with dark background
    2. Browser console shows no errors from @pixi/react or pixi-viewport initialization
    3. Dragging on the canvas pans the viewport (even with empty content, the background should shift)
    4. Scroll wheel zooms in/out smoothly
    5. Texture generation creates 30 textures (10 terrains x 3 variants) -- log count to console
  </verify>
  <done>
    PixiJS canvas renders with @pixi/react Application. pixi-viewport provides smooth pan (drag), zoom (scroll wheel), and decelerate. 30 terrain textures generated at runtime from offscreen Canvas 2D. Canvas is ready to receive hex sprite layers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Render hex terrain sprites with layered containers and viewport culling</name>
  <files>
    packages/client/src/canvas/layers/TerrainLayer.tsx
    packages/client/src/canvas/layers/GridLineLayer.tsx
    packages/client/src/canvas/HexSprite.tsx
    packages/client/src/App.tsx
  </files>
  <action>
    **packages/client/src/canvas/layers/TerrainLayer.tsx -- Sprite-based hex rendering:**

    1. Read hex data from `useMapStore` (hexes Map, gridWidth, gridHeight)
    2. Read terrain textures from the texture generation system
    3. For each hex in the store, create a Sprite positioned at the hex's pixel coordinates:
       - Get pixel position from honeycomb-grid hex object (hex.x, hex.y with topLeft origin)
       - Look up terrain texture by type + variant: `getTerrainTexture(hexData.terrain, hexData.terrainVariant)`
       - Position sprite at (hex.x, hex.y)
       - If using `origin: 'topLeft'`, sprite anchor should be (0, 0). If using center origin, anchor should be (0.5, 0.5). Be consistent with GameHex origin setting from Plan 01.
    4. Implement viewport culling (RESEARCH.md Pattern 4):
       - On viewport move/zoom events, calculate which hex coordinate range is visible
       - Only render Sprites for visible hexes (plus 1-hex padding for smooth scrolling)
       - Use the viewport's `left`, `right`, `top`, `bottom` world-coordinate bounds
       - Convert bounds to hex coordinates using pixelToHex conversion
       - This is the performance-critical optimization: O(visible) not O(total)
    5. Render all hex sprites inside a `<pixiContainer>` (the terrain layer)

    IMPORTANT: Use Sprites, NOT Graphics.drawPolygon for hex tiles (PITFALL 1). Graphics breaks GPU batching and causes frame drops at 500+ hexes.
    IMPORTANT: Do NOT re-create the honeycomb-grid Grid object on every render (Anti-Pattern from RESEARCH.md). Create once and store in a ref or outside the component.

    **packages/client/src/canvas/layers/GridLineLayer.tsx -- Hex outlines:**

    1. Draw thin hex outlines over the terrain sprites to show grid boundaries
    2. Use a single Graphics object (or one per visible hex) with the hex corner coordinates
    3. Line style: 1px, semi-transparent white or gray (0xffffff, alpha 0.15-0.25)
    4. Apply the same viewport culling as TerrainLayer -- only draw outlines for visible hexes
    5. This layer sits above TerrainLayer in z-order

    Note: Grid lines CAN use Graphics since they're thin outlines, not filled polygons. The performance concern from PITFALL 1 is about filled hex tiles, not thin outlines.

    **packages/client/src/canvas/HexSprite.tsx (optional helper):**
    - If needed, create a reusable component that renders a single hex sprite
    - May not be needed if TerrainLayer handles sprite creation imperatively for performance
    - Use judgment: declarative @pixi/react JSX for simplicity, or imperative PixiJS for performance. For 500+ sprites, imperative creation in a useTick or useEffect is likely faster than 500+ JSX elements.

    **packages/client/src/App.tsx -- Wire it together:**

    1. Update App.tsx to render a basic layout: full-width container with HexMapCanvas
    2. On mount, initialize the map store with a default 15x15 grid:
       - Create grid using `createGrid(15, 15)` from hex/grid.ts
       - Assign random terrain to each hex (simple random assignment for now -- proper clustering comes in Plan 03)
       - Call `useMapStore.getState().initializeMap(...)` with the hex data
    3. The canvas should immediately show the hex grid with terrain colors

    This wiring is temporary -- Plan 03 will add the creation dialog and proper terrain generation. For now, auto-create a grid on load so we can verify rendering works.
  </action>
  <verify>
    1. `pnpm dev` shows a hex grid rendered with colored terrain hexes
    2. Each hex has a flat-top hexagon shape with terrain color + noise texture
    3. Grid lines visible as thin outlines between hexes
    4. Dragging pans the map smoothly
    5. Scroll wheel zooms in/out smoothly (continuous, not stepped)
    6. Open browser DevTools Performance tab: record while panning -- frame rate stays at or near 60 FPS
    7. Hex coordinates are correct: hexes tile without gaps or overlaps
    8. At least 200+ hexes visible (15x15 = 225 hexes total)
  </verify>
  <done>
    Hex grid renders on screen with terrain-colored sprites in flat-top orientation. Grid lines show hex boundaries. Pan and zoom work smoothly via pixi-viewport. Viewport culling active for performance. 15x15 grid (225 hexes) renders at 60 FPS. Layered container architecture established (terrain layer, grid line layer).
  </done>
</task>

</tasks>

<verification>
1. Hex grid visible in browser with distinct terrain colors for each hex
2. Pan by dragging: map moves smoothly in all directions
3. Zoom by scroll wheel: continuous smooth zoom (not discrete steps), clamped between 0.25x and 4.0x
4. Hexes are flat-top orientation (flat edge at top and bottom)
5. Hexes tile correctly with no gaps or overlaps
6. Grid lines visible between hexes
7. 60 FPS maintained with 225+ hexes visible (DevTools Performance tab)
8. No PixiJS or @pixi/react errors in console
</verification>

<success_criteria>
- Terrain sprites render using pre-generated textures (not Graphics polygons)
- pixi-viewport provides drag-to-pan, scroll-to-zoom, pinch-to-zoom, decelerate
- Zoom bounds: 0.25x min, 4.0x max
- Layered containers: terrain (z:0), grid lines (z:1), with room for highlights (z:2) and UI overlay (z:3) in Plan 04
- Viewport culling active (only visible hexes rendered)
- 60 FPS with 500+ hexes (verifiable by increasing grid size)
</success_criteria>

<output>
After completion, create `.planning/phases/01-hex-grid-foundation/01-02-SUMMARY.md`
</output>
